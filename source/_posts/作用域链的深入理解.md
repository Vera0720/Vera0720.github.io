---
title: 作用域链的深入理解
date: 2019-03-15 08:13:24
tags: js
---
学习完作用域与执行环境，在来看看什么是作用域链。从基础开始看js是如何执行的？

<!-- more -->

## 编译原理
### 分词/词法解析

    var sum = 30;
    // 词法分析后的结果
    [
      "var" : "keyword",
      "sum" : "identifier",
      "="   : "assignment",
      "30"  : "integer",
      ";"   : "eos" (end of statement)
    ]

### 语法分析
把词法单元流数组转换成一个由元素逐级嵌套所组成的代表程序语法结构的树，这个树被称为“抽象语法树” (Abstract Syntax Tree, 简称AST)。

### 代码生成
将抽象语法树（AST）转换为一组机器指令，也就是可执行代码，简单说，就是用来创建一个变量a，并将3这个值储存在a中。

### JavaScript编译过程的不同处

- JavaScript大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内
- JavaScript引擎用尽了各种办法(比如JIT，可以延迟编译甚至实施重编译)来保证性能最佳

## JavaScript是如何执行的

![1](/image/作用域链的深入理解/1.jpg) 

然后让我们举个例子

    var x = 1;                         //定义一个全局变量 x
    function A(y){
      var x = 2;                       //定义一个局部变量 x
      function B(z){                   //定义一个内部函数 B
        console.log(x+y+z);
      }
      return B;                        //返回函数B的引用
    }
    var C = A(1);                      //执行A,返回B
    C(1);                              //执行函数B，输出 4
    
### 全局初始化
JS引擎在进入一段可执行代码时，会完成三项初始化工作：
- 首先，创建一个全局对象，该对象全局只存在一份，会伴随应用程序的整个生命周期，它的属性在应用程序的各个地方均可访问。我们平时经常用到的一些对象，如Math、String、Date、document等都是它的属性。由于这个全局对象不能通过名字直接访问，因此还有另外一个属性window，并将window指向了自身，这样就可以通过window访问这个全局对象了。用伪代码模拟全局对象的大体结构如下：

    var globalObject = {
      Math:{},
      String:{},
      Date:{},
      document:{},                //DOM操作
      ...
      window:this                 //让window属性指向了自身
    }
    
- 然后，JS引擎需要构建一个执行环境栈，同时创建一个全局执行环境，并将全局执行环境压入到执行环境栈中。执行环境栈的主要作用是保证应用程序能够按照正确的顺序执行。在JavaScript中，每个函数都会有自己的执行环境，当执行一个函数的时候，改函数的执行环境就会压入到执行环境栈的栈顶，并获得执行权，当函数执行完毕，函数的执行环境从栈顶移除，并将执行权交给之前的执行环境。用伪代码来模拟执行环境栈和执行环境的关系如下：

    var ECStack = [];      //定义一个执行环境栈，类似于数组
    
    var EC = {};           //创建一个执行空间，
    //ECMA-262规范并没有对EC的数据结构做明确的定义，你可以理解为在内存中分配的一块空间
    
    ECStack.push(EC);     //进入函数，压入执行环境
    ECStack.pop(EC);      //函数返回后，删除执行环境

- 最后，JS引擎需要创建一个与全局执行环境相关联的全局变量对象，并把全局变量对象指向全局对象，全局变量对象不仅包含全局对象的原有属性，还包括我们在全局定义的变量和函数，如变量x、函数A。于此同时，在定义函数A的时候，会为函数A添加一个scope属性，指向函数A定义时所处的环境，即全局变量对象。在JavaScript中，每个函数在定义的时候，都会创建一个与之关联的scope属性，scope总是指向定义函数时所在的环境（记住这句话，很重要，很关键）。此时执行环境栈的结构如下：

    ECStack = [                              //执行环境栈
      EC(G) = {                              //全局执行环境
        VO(G):{                              //定义全局变量对象
          ...                                //包含全局对象原有的属性
          x: 1,                              //定义变量x
          A: function(){...},                //定义函数A
          A[[scope]]: this                   //定义A的scope，并赋值为VO本身
        }
      }
    ];

### 执行函数A

当执行进入A(1) 时，JS引擎需要完成以下工作：

- 首先，JS引擎会创建函数A的执行环境，然后将函数A的执行环境压入到执行环境栈的栈顶并获得执行权。此时执行环境栈中有两个执行环境，分别是全局执行环境和函数A执行环境。

- 然后，创建函数A执行环境的作用域链，在JavaScript中，每个执行环境都会有自己的作用域链，用于标识符的解析，当执行环境被创建时，它的作用域链就初始化为当前运行函数的scope属性所包含的对象。

- 接着，JS引擎会创建一个与当前函数执行环境相关联的活动对象，这里的活动对象扮演着变量对象的角色，只是在函数中的叫法不同而已（你可以认为变量对象是一个总的概念，而活动对象是它的一个分支）。活动对象包含函数的形参、arguments对象，this以及局部定义的变量和函数。然后该活动对象会被加入到作用域链的顶端。需要注意的是，在定义函数B的时候，JS引擎同样也会为B添加了一个scope属性，并将scope指向了定义函数B时所在的环境，定义函数B的环境就是A的活动对象AO， 而AO位于链表的前端，由于链表具有首尾相连的特点，因此函数B的scope指向了A的整个作用域链。 我们再看看此时的ECStack结构：


    ECStack = [                                //执行环境栈
      EC(A) = {                                //A的执行环境
        [scope]:VO(G),                         //VO是全局变量对象，在JavaScript中，每个函数在定义的时候，都会创建一个与之关联的scope属性，scope总是指向定义函数时所在的环境。
          AO(A) : {                            //创建函数A的活动对象
            y: 1,                              //A的形参
            x: 2,                              //定义局部变量x
            B: function(){...},                //定义函数B
            B[[scope]]:  this,                 //this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链
            arguments: [],                     //平时我们在函数中访问的arguments就是AO中的arguments
            this: window                       //函数中的this指向调用者window对象
          },
          scopeChain: [AO(A),A[[scope]]]       //链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)->VO(G)
      },
      EC(G) = {                                //全局执行环境
        VO(G):{                                //创建全局变量对象
          ...                                  //包含全局对象原有的属性
          x: 1,                                //定义变量x
          A: function(){...},                  //定义函数A
          A[[scope]]: this                     //定义A的scope，A[[scope]] == VO(G)
        }
      }
    ];

### 执行函数B
函数A被执行以后，返回了B的引用，并赋值给了变量C，执行 C(1) 就相当于执行B(1)，JS引擎需要完成以下工作：
- 首先，创建函数B的执行环境，并加入到执行环境栈的栈顶获得执行权（当函数A返回后，A的执行环境就会从栈中被删除，只留下全局执行环境）。
- 然后，创建函数B执行环境的作用域链，初始化为函数B的scope所包含的对象，即包含了A的作用域链。
- 最后，创建函数B执行环境相关联的活动对象。此时ECStack将会变成这样：


    ECStack = [                                //执行环境栈
      EC(B) = {                                //创建B的执行环境,并处于作用域链的顶端
        [scope]:AO(A),                         //指向函数A的作用域链,AO(A)->VO(G)
        AO(B) = {                          //创建函数B的活动对象
          z: 1,
          arguments: [],
          this: window
        }
        scopeChain: [AO(B),B[[scope]]]          //链表初始化为B[[scope]],再将AO(B)加入链表表头，此时B的作用域链：AO(B)->AO(A)-VO(G)
      },
      EC(G) = {                                //全局执行环境
        VO:{                                   //定义全局变量对象
          ...                                  //包含全局对象原有的属性
          x: 1,                                //定义变量x
          A: function(){...},                  //定义函数A
          A[[scope]]: this                     //定义A的scope，A[[scope]] == VO(G)
        }
      }
    ];
    
当函数B执行“x+y+z”时，需要对x、y、z 三个标识符进行一一解析，解析过程遵守变量查找规则：先查找自己的活动对象中是否存在该属性，如果存在，则停止查找并返回；如果不存在，继续沿着其作用域链从顶端依次查找，直到找到为止，如果整个作用域链上都未找到该变量，则返回“undefined”。从上面的分析可以看出函数B的作用域链是这样的：

AO(B)->AO(A)->VO(G)

因此，变量x会在AO(A)中被找到，而不会查找VO(G)中的x，变量y也会在AO(A)中被找到，变量z 在自身的AO(B)中就找到了。所以执行结果：2+1+1=4.

总结
当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是，保证对执行环境有权访问的变量和函数进行有序访问。作用域链前端始终是当前执行代码所在环境的变量对象，如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始只包含一个便阿玲，即arguments对象，作用域链中下一个变量对象来自包含环境，一直延续到全局执行环境。
作用域链本质上是一个指向变量对象的指针列表，只引用但不实际包含变量对象









