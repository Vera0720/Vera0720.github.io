---
title: 函数式编程
date: 2020-01-01 10:11:48
tags: js
---
在JavaScript中，函数是一等值。何谓一等？一等，是编程语言中值的通用修饰词，只要某个值满足以下三个条件，就能被成为一等值：
1.可以作为参数传递给函数
2.可以作为函数的返回值
3.可以赋值给变量

<!-- more -->

众所周知 JavaScript 是一种拥有很多共享状态的动态语言，慢慢的，代码就会积累足够的复杂性，变得笨拙难以维护。当我们在设计应用程序的时候，我们应该考虑是否遵守了以下的设计原则。
- 可扩展性--我是否需要不断地重构代码来支持额外的功能？
- 易模块化--如果我更改了一个文件，另一个文件是否会受到影响？
- 可重用性--是否有很多重复的代码？
- 可测试性--给这些函数添加单元测试是否让我纠结？
- 易推理性--我写的代码是否非结构化严重并难以推理？

什么是函数式编程？
函数式编程是声明式编程的一部分。javascript中的函数是第一类公民，这意味着函数是数据，你可以像保存变量一样在应用程序中保存、检索和传递这些函数。
简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变。

<!-- more -->

### 举个例子

现在的需求就是输出在网页上输出 “Hello World”。

一般的初学者会这样写：

    document.querySelector('#msg').innerHTML = '<h1>Hello World</h1>'

如果想复用，改变消息格式内容，所以可能有经验的前端开发者会这么写：

    function printMessage(elementId, format, message) {
      document.querySelector(elementId).innerHTML = `<${format}>${message}</${format}>`
    }
    printMessage('msg', 'h1', 'Hello World')

如果是要将文本写入文件，而不是插入到HTML中，那么会怎么写这段代码呢
    
    const printMessage = compose(addToDom, h1, echo)
    printMessage('Hello World')

其中h1、echo、addToDom和compose都是函数，compose函数尤为关键，它的每个参数都是函数，自右向左执行参数，下一个函数接收上一个函数的执行结果作为参数。
那么我们为什么要写成这样呢？看起来多了很多函数。其实我们是将程序分解为一些更可重用、更可靠且更易于理解的部分，然后再将他们组合起来，形成一个更易推理的程序整体。

如果我想重复的显示Hello World

    var printMessaage = compose(console.log, repeat(3), echo)
    printMessage(‘Hello World’)

### 基本概念

#### 声明式编程

声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做。它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件。它没有描述控制流步骤。声明式编程的例子有HTML、SQL等
声明式编程的编写方式描述了应该做什么，而命令式编程描述了如何做。在声明式编程中，让编译器决定如何做事情。声明性程序很容易推理，因为代码本身描述了它在做什么。
来看一组代码再来对比一下命令式编程和声明式编程

    // 命令式方式
    var array = [0, 1, 2, 3]
    for(let i = 0; i < array.length; i++) {
        array[i] = Math.pow(array[i], 2)
    }
    
    array; // [0, 1, 4, 9]
    
    // 声明式方式
    [0, 1, 2, 3].map(num => Math.pow(num, 2))


#### 不可变数据

创建不可变数据的主要实现思路就是：一次更新过程中，不应该改变原有对象，只需要新创建一个对象用来承载新的数据状态。
来看一个例子

    const student1 = {
        school: "北大", 
        sex:'woman',
        name: 'jack',
        birthday: '1996-7-20',
    }
    
    const changeStudent = (student, newName, newBirthday) => {
        return {
            ...student,             // 使用解构
            name: newName,          // 覆盖name属性
            birthday: newBirthday   // birthday
        }
    }
    
    const student2 = changeStudent(student1, 'cherry', '1993-6-14')

#### 纯函数

纯函数指没有副作用的函数，相同的输入有相同的输出。

常常这些情况会产生副作用。

- 改变一个函数参数的原始值
- 读取作用域外的其他变量
- 改变作用域外的其他变量
- 处理用户输入
- 抛出一个异常
- 屏幕打印或记录日志
- 访问浏览器的Cookie
- 发起一个网络请求
- DOM查询/操作

所以纯函数有如下特性：

- 变量都只在函数作用域内获取, 作为的函数的参数传入
- 不会产生副作用, 不会改变被传入的数据或者其他数据
- 相同的输入保证相同的输出

但是在我们平时的开发中，有一些副作用是难以避免的，与外部的存储系统或 DOM 交互等，我们可以通过将其从主逻辑中分离出来，使他们易于管理。

看下面的例子，通过id找到学生的记录并渲染在浏览器(在写程序的时候要想到可能也会写到控制台，数据库或者文件，所以要想如何让自己的代码能重用)中。

    // 命令式代码
    function showStudent(id) {
        // 这里假如是同步查询
        var student = db.get(id)
        if(student !== null) {
              // 读取外部的 elementId
              document.querySelector(`${elementId}`).innerHTML = `${student.id},${student.name},${student.lastname}`
        } else {
            throw new Error('not found')
        }
    }
    showStudent('666')
    
    // 函数式代码
    
    // 通过 find 函数找到学生
    var find = curry(function(db, id) {
        var obj = db.get(id)
        if(obj === null) {
            throw new Error('not fount')
        }
        
        return obj
    })
    
    // 将学生对象 format
    var csv = (student) => `${student.id},${student.name},${student.lastname}`
    
    // 在屏幕上显示
    var append = curry(function(elementId, info) {
        document.querySelector(elementId).innerHTML = info
    })
    
    var showStudent = compose(append('#student-info'), csv, find(db))
    
    showStudent('666')

#### 高阶函数

高阶函数是将函数作为参数或返回函数的函数，或者有时它们都有。 这些高阶函数可以操纵其他函数。Array.map，Array.filter和Array.reduce是高阶函数，因为它们将函数作为参数。

    function foo(x, bar){
       return bar(x)
    }

高阶函数在JS中的应用比比皆是，其中ECMAScript5中提供的一些数组方法就是典型的高阶函数，比如：forEach()、map()、reduce()、reduceRight()、filter()、every()、some()等。

#### lambda表达式

lambda 表达式其实是一个匿名函数，使用箭头清晰的表示输入输出的映射关系，JavaScript 中使用箭头函数来实现。

#### 递归

递归是一种函数在满足一定条件之前调用自身的技术。只要可能，最好使用递归而不是循环。你必须注意这一点，浏览器不能处理太多递归和抛出错误。

#### 组合

在React中，我们将功能划分为小型可重用的纯函数，我们必须将所有这些可重用的函数放在一起，最终使其成为产品。 将所有较小的函数组合成更大的函数，最终，得到一个应用程序，这称为组合。实现组合有许多不同方法。 我们从Javascript中了解到的一种常见方法是链接。 链接是一种使用点表示法调用前一个函数的返回值的函数的方法。但在React中，我们使用了不同于链接的方法，因为如果有30个这样的函数，就很难进行链接。这里的目的是将所有更简单的函数组合起来生成一个更高阶的函数。

    const name = compose(
    splitmyName,
    countEachName,
    comvertUpperCase,
    returnName
    )
    
    console.log(name);
    
#### 柯里化

是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。柯里化的作用就是解决基础函数如果是多参数函数，就不能作为参数传递给组合函数的问题。

举个例子
比如你有一间店铺，并且你想给你顾客打个九个优惠，现在我们需要计算优惠了多少钱
    
    function discount(price, discount) {
      return price * discount
    }
    
你可以预见，从长远来看，我们会发现自己每天都在计算打九折的优惠   

    const price1 = discount(1500, 0.10); // $150
    const price2 = discount(2000, 0.10); // $200

我们可以将 discount 函数柯里化，这样我们就不用总是每次计算时都输入这 0.10 的折扣。

    // 这个就是一个柯里化函数，将本来两个参数的 discount ，转化为每次接收单个参数完成求职
    function discountCurry(discount) {
        return (price) => {
            return price * discount;
        }
    }
    const tenPercentDiscount = discountCurry(0.1);
    
    // 现在，我们可以只计算你的顾客买的物品都价格了：
    tenPercentDiscount(500); // $50

同样地，有些至尊vip客户，我们需要为他们提供 20% 的折扣。 可以使用我们的柯里化的discount函数：

    onst twentyPercentDiscount = discountCurry(0.2);
    twentyPercentDiscount(500); // $100

这就是柯里化，下面举个栗子说明柯里化在函数式编程里的应用

假设现在我们有这么一个需求：给定的一个字符串，先翻转，然后转大写，找是否有JD，如果有那么就输出 yes，否则就输出 no。

    function stringToUpper(str) {
      return str.toUpperCase()
    }
    
    function stringReverse(str) {
      return str.split('').reverse().join('')
    }
    
    function find(str, targetStr) {
      return str.includes(targetStr)
    }
    
    function judge(is) {
      console.log(is ? 'yes' : 'no')
    }

我们很容易就写出了这四个函数，现在我们想通过组合函数的方式来实现，但是我们的 find 函数要接受两个参数，不符合组合函数参数的规定，这个时候我们像前面一个例子一样，把 find 函数柯里化一下，然后再进行组合：

    // 柯里化 find 函数
    function findCurry(targetStr) {
        return str => str.includes(targetStr)
    }
    
    const findTaoweng = findCurry('JD')
    
    const result = compose(judge, findTaoweng, stringReverse, stringToUpper)













