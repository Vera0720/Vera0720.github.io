---
title: 前端优化系列之错误处理
date: 2019-04-25 10:41:33
tags: js
---
今天搞出了一个线上事故，由于业务原因，我在所有的业务处理逻辑前加了一行
    
    if(str.includes('aaa')){
    
        return
    
    }
   
但因为这个某些低版本浏览器不支持es6语法，上线后就出错了，有的人就直接打不开了。
所以解决这个问题后，我突然联想到，错误处理是多么的重要。今天来整理下，前端的常用的错误处理都有哪些。

<!-- more -->

## 为什么要处理异常？

异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。
1.增强用户体验；
2.远程定位问题；
3.及早发现问题；
4.无法复线问题，尤其是移动端，机型，系统都是问题；
5.完善的前端方案，前端监控系统；
对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。

## 需要处理哪些异常？
JS 语法错误、代码异常
静态资源加载异常
Promise异常

- try-catch语句：try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。

- window.onerror：当JS运行时错误发生时，window会触发一个ErrorEvent接口的 error事件，并执行window.onerror()。
不论是静态资源异常，或者接口异常，错误都无法捕获到。最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；
window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx
    
    
    window.onerror = function(){
        console.log('error')
        return true
    }
    
在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。

- window.addEventListener
当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的window.addEventListener 捕获。


    window.addEventListener('error',function(e){
      var typeName = e.target.localName;
      var sourceUrl = "";
      if (typeName === "link") {
        sourceUrl = e.target.href;
      } else if (typeName === "script") {
        sourceUrl = e.target.src;
      }
      console.log('error',sourceUrl)
    }, true);

- unhandledrejection
为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error

    
    window.addEventListener('unhandledrejection',function(e){
          console.log(e)
        }, true);
    
- 统一封装请求方法
对一些请求，封装统一的方法，对http状态码进行判断，做对应的拖底处理

