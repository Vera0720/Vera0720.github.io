---
title: this解析
date: 2019-01-01 16:01:08
tags: js
---

### 调用位置

this是在运行的时候进行绑定的，并不是在编写的时候绑定的，他的上下文取决于函数调用时的各种条件，this 的绑定和函数声明的位置没有任何关系，只取决与函数的调用方式

<!-- more -->

### 绑定规则

- 默认绑定

一个直白，毫无修饰的调用

- 隐式绑定


    function foo() {
    	console.log( this.a );
    }
    
    var obj = {
    	a: 2,
    	foo: foo
    };
    
    obj.foo(); // 2
    
首先，注意foo()被声明然后作为引用属性添加到obj上的方式。无论foo()是否一开始就在obj上被声明，还是后来作为引用添加（如上面代码所示），这个函数都不被obj所真正“拥有”或“包含”。
然而，调用点使用obj环境来引用函数，所以你可以说obj对象在函数被调用的时间点上“拥有”或“包含”这个函数引用。
不论你怎样称呼这个模式，在foo()被调用的位置上，它被冠以一个指向obj的对象引用。当一个方法引用存在一个环境对象时，隐含绑定规则会说：是这个对象应当被用于这个函数调用的this绑定。
因为obj是foo()调用的this，所以this.a就是 obj.a 的同义词。
只有对象属性引用链的最后一层是影响调用点的。

把函数中的this绑定到这个上下文对象，也可以说函数被调用时拥有它或者包含它
隐式绑定的函数会丢失绑定对象，也就是说他会应用默认绑定，把this绑定到全局上对象或者undefined上（这里取决与是否时严格模式）

- 显式绑定

1.硬绑定

    function foo() {
        console.log( this.a );
    }
    
    var obj = {
        a: 2
    };
    
    var bar = function() {
        foo.call( obj );
    };
    
    bar(); // 2
    setTimeout( bar, 100 ); // 2
    
    // `bar` 将 `foo` 的 `this` 硬绑定到 `obj`
    // 所以它不可以被覆盖
    bar.call( window ); // 2
    
我们创建了一个函数 bar()，在它的内部手动调用 foo.call(obj)，由此强制 this 绑定到 obj 并调用 foo。无论你过后怎样调用函数 bar，它总是手动使用 obj 调用 foo。这种绑定即明确又坚定，所以我们称之为 硬绑定（hard binding）

后来就增加了bind()函数，提供哥我们用作硬绑定

2.call和apply

foo.call(obj)会使foo调用的时候强制把他的this绑定到obj上
function.call(obj,arr1,arr2...)
function.apply(obj,[arr])
如果没有提供arr和obj任何一个参数，那么Global对象将被用作obj，并且无法被传递任何参数。

- new绑定

所有函数都可以通过new来调用，这种函数调用被称作构造函数调用，实际上并不存在所谓的构造函数，只有对于函数的构造调用。

使用new调用函数发生构造函数调用时，执行以下操作
1.创建一个全新的对象
2.这个新对象会被执行prototype链接
3.这个新对象会绑定到函数调用的this
4.如果函数中没有返回其他的对象，那么new表达式中的函数调用会自动返回这个新对象

### 判断this的规则

1.判断是否new绑定，如果是的话，this绑定的是新创建的对象
2.函数是否通过call,apply进行的显示绑定或硬绑定，如果是，this绑定的是制定的对象
3.函数是够在某个上下文中调用，即隐式绑定，如果是，就绑定到那个上下文对象
4.如果以上都不是，即默认绑定，如果在严格模式下，就绑定到undefined,否则绑定到全局对象









