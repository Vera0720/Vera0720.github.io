---
title: 前端必会的算法题目
date: 2020-03-12 22:47:08
tags: 算法
---

好久没有写过算法题啦，今年目标刷完100道leetcode。还是要有一个目标的，万一实现了呢～

<!-- more -->

## 单向链表

上代码

    
    // 链表存储有序的集合，但不同于数组
    // 链表中的元素在内存中并不是连续放置的
    // 每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成
    
    function LinkedList() {
    
        function Node (element) {
            this.element = element
            this.next = null
        }
        let length = 0
        let head = null
    
        // 向链表尾部追加元素
        this.append = function (element) {
            let node = new Node(element)
            let current
            if (head === null) { // 列表中第一个节点
                head = node
            } else {
                current = head
                while (current.next) {
                    current = current.next // 找到最后一项，是null
                }
                current.next = node // 给最后一项赋值
            }
            length++ // 更新列表的长度
        }
    
        // 向链表中间增加元素
        this.insert = function (position,element) {
            if(position >= 0 && position <= length){
                let node = new Node(element)
                let current = head
                let previous = null
                let index = 0
                // 如果当前的位置是0，就把插入的元素设置成head
                if(position === 0){
                    node.next = current
                    head = node
                }else{
                    while(index < position){
                        previous = current
                        current = current.next
                        index ++
                    }
                    node.next = current
                    previous.next = node
                }
                length++
                return true
            } else{
                return false
            }
        }
    
        // 从链表中移除指定位置的元素
        this.remove = function (position) {
            if(position >= 0 && position <= length){
                let current = head
                let previous = 0
                let index = 0
                if (position === 0) { //  移除第一项
                    head = current.next
                }else{
                    while(index < position){
                        previous = current
                        current = current.next
                        index ++
                    }
                    previous.next = current.next
                }
                length --
                return true
            } else{
                return false
            }
        }
    
        // 把链表内的值转换成一个字符串
        this.toString = function () {
            let current = head,
                string = ''
            while (current) {
                string += current.element + ','
                current = current.next
            }
            return string
        }
    
    }
    
    let list = new LinkedList()
    list.append('a')
    list.append('b')
    list.insert(1, 'hello')
    console.log(list.toString())
    list.remove(0)
    console.log(list.toString())

## 回文
    
    function checkPalindrom(str) {  
        return str == str.split('').reverse().join('');
    }

## 数组去重

    let obj = {}
    let newArr = []
    for(let i = 0; i < arr.length; i++) {
        if(!obj[arr[i]]){
            obj[arr[i]] = 1
            newArr.push(arr[i])
        }
    }
    console.log(newArr)
    // nan，object都能过滤掉，但是会把‘nan’和nan视为同一个

## 统计字符中出现频率最高的一个

    function findMaxDuplicateChar (str) {
        if(str.length == 0){
            return false
        }
        if(str.length == 1){
            return str
        }
        let obj = {}
        for(let i = 0;i<str.length;i++){
            if(!obj[str.charAt(i)]){
                obj[str.charAt(i)] = 1
            }else{
                obj[str.charAt(i)] += 1
            }
        }
        
        let maxValue = 1
        let maxChar = ''
        
        
        for(let i in obj){
            if(obj[i] > maxValue){
                maxValue = obj[i]
                maxChar = i
            }
        }
        return (maxChar + ':' + maxValue)
        
    }

## 不借助临时变量，进行两个整数的交换

    function swap(a , b) {  
      b = b - a;
      a = a + b;
      b = a - b;
      return [a,b];
    }

## 斐波那契数列

    公式：arr[i] = arr[i-1]+arr[i-2];  

    function fbnq(n){
        var arr = []
        n为斐波那契的总共位数,循环位数进行数组创建
        for(let i = 0;i<n;i++){
            // 因为要考虑第0位和第1位，第2位
            if(i>=2){
                arr.push(arr[i-1]+arr[i-2])
            }else{
                arr.push(i)
            }
        }
        return arr
    }

## 找出下列正数组的最大差值，即最大值-最小值

    function getMaxProfit(arr){
        arr.sort(function(a, b){return a - b})
        return (arr[arr.length-1]- arr[0])
    }
    
## 随机生成指定长度的字符串

    function randomString(str,n) {  
        let str = str || 'abcdefghijklmnopqrstuvwxyz9876543210';
        let newStr = ''
        for(let i = 0;i<n;i++){
            newStr += str.charAt(Math.round(Math.random() * str.length))
        }
        return newStr
    }
## 快速排序
算法步骤：
1.从数列中挑出一个元素，称为基准
2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有愿所有比基准值大的摆在基准的后面（相同的数可以到任意一边），在这个分区退出之后，该基准就处于数列的中间位置，这个称之为分区操作。
3.递归的把所有小于基准值元素的子数列和大于基准值元素的子数列排序
递归的最底部情形是数列的大小是0或1，也就是永远都已经被排序好了，虽然一直递归下去，但这个方法总会退出，因为在每次的迭代中，它至少把一个元素摆到它最后的位置去。
   
       function qSort(a,left,right){
           var mid = a[left];
           while(left<right){
               while(a[right]>mid&&left<right)right--;
               if(left<right)
                   a[left++]=a[right];
               while(a[left]<mid&&left<right) left++;
               if(left<right)
                   a[right--]=a[left];
           }
           a[left] = mid;
           return left;
       }
       function quickSort(a,left,right){
           if(left<right){
               var mid = qSort(a,left,right);
               quickSort(a,left,mid-1);
               quickSort(a,mid+1,right);
           }
       }
       var a=[25,79,44,11,36,42,8];
       quickSort(a,0, a.length-1);
       for(var i=0; i< a.length;i++){
           console.log(a[i]);
       }
  
## 冒泡排序
   
算法步骤：
1.比较相邻的元素，如果第一个比第二个大，就交换他们两个
2.对每一对相邻的元素作同样的工作，从开始第一对到结尾的最后一对，这步做完后，最后的元素会是最大的数
3.针对所有的元素重复以上步骤，除了最后一个
4.持续对每次越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
代码示例：
   
       var a=[38,9,2,14,6];
       for(var i=0;i<a.length;i++){
           for(var j=0;j<a.length-1;j++){
               if(a[j+1]>a[j]){
                   a[j]=a[j]+a[j+1];
                   a[j+1]=a[j]-a[j+1];
                   a[j]=a[j]-a[j+1];
               }
           }
           console.log(a[i]);
       }    
  
## 二分查找
1.从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。
2.如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。
3.如果某一步数组为空，则表示找不到目标元素。

    function binary_search (arr,key) {
        let low = 0
        let high = arr.length - 1
        
        while (low <= high){
            let mid = parseInt((low+high)/2)
            // 如果一样，直接找到了
            if(key == arr[mid]){
                return  mid;
            }
            // 如果想要查找的值大于
            else if(key > arr[mid]){
                low = mid + 1
            }
            else if(key < arr[mid]){
               high = mid -1;
            }
            else{
                return -1
            }
        }
    
    }
      
## 找到数组的中位数

