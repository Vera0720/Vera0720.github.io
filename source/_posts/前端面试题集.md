---
title: 前端面试题集
date: 2017-11-11 22:30:22
tags: 面试
---
按照分类整理了一波面试题，后续会慢慢补充答案的。

<!-- more -->

## HTTP
### 服务器接受请求时head头里能拿到什么
Headers主要分为Response Headers（响应）和Request Headers（请求）两部分
### http缓存
强制缓存（cache-control:max-age || Expries），对比缓存(lastmodified && ETag)

浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）
F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since
Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作

html页面禁用缓存的设置如下：

    <meta http-equiv="pragma" content="no-cache">
    // 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求
    <meta http-equiv="cache-control" content="no-cache">
    // 其他主流浏览器识别的标签
    <meta http-equiv="expires" content="0">
    // 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段
    html设置缓存如下：
    <meta http-equiv="Cache-Control" content="max-age=7200" />
    // 其他主流浏览器识别的标签
    <meta http-equiv="Expires" content="Mon, 20 Aug 2018 23:00:00 GMT" />
    // 仅有IE浏览器才识别的标签

### 输入url发生什么

1.浏览器的地址栏输入url并按下回车

2.浏览器查找当前url是否存在缓存，并比较缓存是否过期

3.DNS解析url对应的IP

4.根据IP建立TCP连接（三次握手）

5.服务器端处理（动态页面处理，静态页面返回。CDN相关）

6.HTTP发起请求

7.服务器处理请求，浏览器接收HTTP响应

8.渲染页面，构建DOM树（收到HTML内容解析，并行加载串行执行执行CSS，js）

9.请求头内容缓存到浏览器端

10.关闭TCP连接，4次握手

## CSS

### 盒模型
> 标准盒模型及怪异盒模型，box-sizing:content-box/border-box

        // 标准盒模型，实际宽为200+1*2+10*2
        .content-box{
            box-sizing:content-box;
            width:200px;
            height:200px;
            border:1px solid #000;
            padding:10px;
        }
        // 怪异盒模型,实际宽为200（10*2+1*2+178）
        .content-box{
            box-sizing:border-box;
            width:200px;
            height:200px;
            border:1px solid #000;
            padding:10px;
            margin:10px;
        }
### flex
>弹性盒模型，不兼容ie9以下

        1.容器基本属性：
        - flex-direction(主轴方向的排列方法):row/row-reverse/column/column-reverse
        - flex-wrap: wrap/no-wrap/wrap-reverse
        - flex-flow: <flex-direction>  <flex-wrap>;
        - justify-content（项目在主轴上的对齐方式）: center/flex-start/flex-end/space-between/space-around
        - align-items（项目在交叉上的对齐方式）: center/flex-start/flex-end/baseline（项目的第一行文字的基线对齐）/stretch（如果项目未设置高度或设为auto，将占满整个容器的高度。）
        - align-content（定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用）: flex-start | flex-end | center | space-between | space-around | stretch
        2. 项目基本属性
        - order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。
        - flex-grow:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
        - flex-shrink:项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。0为原有大小
        - flex-basis: 在分配多余空间之前，项目占据的主轴空间 <length> | auto
        - flex:flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
        - align-self:单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。
### input的placeholder
>
        css选择:input::placeholder
        垂直居中:line-height: normal
    
### rem原理
>本质是等比缩放，一般是基于宽度。一般是通过两种方式来设置

        1.sass
        
        $width: 750; /* ui图的宽度 */
        
        @function px2rem($px) {
          @return #{$px/$width*100}rem;
        }
        
        p {
          width: px2rem(100);
        }
        
        2.head头里计算根结点字体大小
        
        window.onresize = function () {
            resetFontSize()
        };
        function resetFontSize() {
            document.documentElement.style.fontSize = document.documentElement.clientWidth / 3.75 + 'px';
        }
        resetFontSize()
### box-show
    
    box-shadow: h-shadow v-shadow blur(模糊距离) spread(阴影的大小) color inset;

单边阴影主要是改变阴影的大小，配合水平和垂直位移
### 水平垂直居中
>可以通过flex布局，position+margin/transform:translate(-50%,-50%)
### 动画
>animation/transition/transform

        // animation
        @keyframes actWith {
            from {
                background: red;
            }
            to{
                background: yellow;
            }
        }
        @keyframes actWith {
            10% {
                background: red;
            }
            50%{
                background: yellow;
            }
            100%{
                background: blue;
            }
        }
        div {
            animation: actWith 5s;          
            // animation: name duration timing-function（line,ease...） delay iteration-count direction fill-mode play-state;
        }
        
        // transition 需要事件的触发
        // transition: property duration timing-function delay;
        div{
            // transform  旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix
            transform:rotate(7deg);
        }
               
### 定位
>static(不同里文档流，默认)，relative(相对与原有本身位置，不脱离文档流)，absolute(相对非static已定位最近父元素,脱离文档流)，fixed(相对与当前浏览器窗口，脱离文档流)
### BFC
>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
        
        - 布局规则
        1.内部的Box会在垂直方向，一个接一个地放置。
        2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。   
        3.每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
        4.BFC的区域不会与float box重叠。
        5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
        - 如何创建BFC
        1.float非none
        2.position非statcic,relative
        3.overflow非visible
        4.display的值为table-call,inline-block,flex,table-caption,inline-flex
        
### margin折叠
>在CSS中，【两个或多个】 【毗邻】 的 【普通流】 中的盒子（可能是父子元素，也可能是兄弟元素）在 【垂直方向】 上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。
        
        .parent1 {
            width: 100px;
            height: 100px;
            background: yellow;
            margin-bottom: 20px;
        }
        .parent2 {
            width: 100px;
            height: 300px;
            margin-top: 30px;
            background: blue;
            margin-bottom: 30px;
        }
        .parent3 {
            width: 100px;
            height: 100px;
            background: green;
            margin-top: 50px;

        }
        .child {
            background: red;
            height: 20px;
            margin-top: 50px;
            margin-bottom: 60px;
        }
        .parent-2{
            width: 100px;
            height: 500px;
            background: black;
        }
        .child-2{
            width: 100px;
            height: 100px;
            margin-top: 50px;
            background: bisque;
        }
                
        <div class="parent1"></div>
        <div class="parent2">
            <div class="child"></div>
            <div class="child"></div>
            <div class="child"></div>
        </div>
        <div class="parent3"></div>
        <div class="parent-2">
            <div class="child-2"></div>
        </div>
            
            
### 让图文不可复制
user-select: none;
### 复制在粘贴板上加一段话
1、答案区域监听copy事件，并阻止这个事件的默认行为。
2、获取选中的内容（window.getSelection()）加上版权信息，然后设置到剪切板（clipboarddata.setData()）。

## Html
1.DOM事件流
事件捕获，处于目标阶段，事件冒泡
通过addlisterner(fun,true/false)
e.target是事件触发的元素，event.currentTarget指向事件绑定的元素（就是冒泡啥的触发可用event.currentTarget来追踪）
2.DOM0级事件与DOM2级事件
DOM0级事件就是找到这个元素，绑定他。取消事件就直接设为null就行了
DOM2级事件就是找到这个元素，监听他的事件。取消事件就直接removeaddListerner
3.浏览器渲染原理
1、构建DOM树
2、CSS标记，构成层叠样式表模型CSSOM
3、将DOM和CSSOM合并为渲染树(rendering tree)
4、渲染树布局，布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。
5、渲染树绘制

## JS
### es6
#### es6的新增语法
let/const/promise/解构/filter/set/map
#### let与var的区别，为什么不能变量提升，重复复值，const为什么在有些情况下可以改变
let 的「创建」过程被提升了，但是初始化没有提升。
var 的「创建」和「初始化」都被提升了。
function 的「创建」「初始化」和「赋值」都被提升了。

如果let x = d ;抱错，x 变量就将永远处于 created 状态。
你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。
由于 x 无法被初始化，所以 x 永远处在暂时死区

let 声明会提升到块顶部
从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区）
如果你在 TDZ 内使用该变量，JS 就会报错

const是赋值本身不可变，对象的地址不可变，但可以对对象增加修改删除属性
### promise
#### promise的常用api
then,catch,resolve,reject,all,race
#### 如何实现一个带休眠的promise
直接在promise里写settimeout延迟2秒触发reject
新建一个定时任务，通过.race，让两个promise进行比较
#### 如何实现两个接口的链式调用
return一个promise用.then调用，也可以用async,await
#### 事件循环
#### promise原理
#### promise.all实现原理

    Promise.all = function (promise) {
        return new Promise((resolve, reject) => {
            let index = 0
            let result = []
            if (promise.length === 0) {
                resolve(result)
            } else {
                function processValue(i, data) {
                    result[i] = data
                    if (++index === promise.length) {
                        resolve(result)
                    }
                }
                for (let i = 0; i < promise.length; i++) {
                    Promise.resolve(promise[i]).then((data) => {
                        processValue(i, data)
                    }, (err) => {
                        reject(err)
                        return
                    })
                }
            }
        })
    }
#### promise.race原理

    function myPromiseRace(promiseArr){
        return new Promise((resolve,reject) => {
            if(!Array.isArray(promiseArr)) throw('参数必须为数组')
            let len = promiseArr.length
            for(let i = 0; i < len; i++){
                Promise.resolve(promiseArr[i]).then(val => {
                    resolve(val)
                }).catch(err => {
                    reject(err)
                })
            }
            
        })
       
    
    }
   
#### then(a,b)与then(a).catch(b)一样么
在then里发生错误的时候，不会被then的第二个函数捕获。
### 数组
#### 数组的方法
push,pop,shift,unshift,splice,slice,indexof,concat,join,sort,reverse,fiflter,map,foreach,find
#### 数组的哪些方法能够改变原数组
pop,push,shift,unshift,sort,reverse,splice
#### 实现一个数组的深拷贝和浅拷贝
        
        
            // 浅拷贝
            let shallowClone = function (obj) {
                // 不是对象的话，return
                if(typeof obj != 'Object'){
                    return false
                }
            
                // 根据类型判断应该新建一个数组还是对象
                let newObj = obj instanceof Array ? [] : {}
                // 遍历obj，只有obj的属性才拷贝
                for(let key in obj){
                    if(obj.hasOwnProperty(key)){
                        newObj[key] = obj[key]
                    }
                }
                return newObj
            }
            // 深拷贝
            let deepClone = function (obj) {
                // 不是对象的话，return
                if(typeof obj != 'object'){
                    return false
                }
            
                // 根据类型判断应该新建一个数组还是对象
                let newObj = obj instanceof Array ? [] : {}
                // 遍历obj，obj所有的属性都拷贝
                for(let key in obj){
                    if(obj.hasOwnProperty(key)){
                        newObj[key] = (typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key])
                    }
                }
                return newObj
            }
#### 查找数组中最大的一个数
1.Math.max(...arr)
2.for
3.sort/sort+reserve
#### 数组去重
- indexOf


    let newArr = []
    arr.forEach(function(item){
         if(newArr.indexOf(item) == -1){
            newArr.push(item)
         }
    })
    // 不能过滤掉 NaN、Object

- for


    let newArr=[];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i+1; j < arr.length; j++) {
            if(arr[i]===arr[j]){
                ++i;
            }
        }
        newArr.push(arr[i]);
    }
    // 不能过滤掉 NaN、Object

- filter


    let newArr = arr.filter((x, index, self)=>{
      // x : 数组每一项的值
      // index: 每一项的下标
      // self: 当前数组
      return self.indexOf(x)===index
    })
    // 不能过滤掉 NaN、Object

- map


    let newArr = []
    let map = new Map()
    for(let i = 0; i < arr.length; i++) {
        if(!map.has(arr[i])) {
            map.set(arr[i])
            newArr.push(arr[i])
        }
    }
    console.log(newArr)
    // 无法过滤对象

- set

    
    new Set(arr)
    // 无法过滤对象

- includes


    let newArr = []
    arr.forEach(function(item){
        if(!newArr.includes(item)){
            newArr.push(item)
        }
    })
    console.log(newArr)
    // 无法过滤对象

- 利用对象的key
    
    
    let obj = {}
    let newArr = []
    for(let i = 0; i < arr.length; i++) {
        if(!obj[arr[i]]){
            obj[arr[i]] = 1
            newArr.push(arr[i])
        }
    }
    console.log(newArr)
    // nan，object都能过滤掉，但是会把‘nan’和nan视为同一个
### == === Object.is
==因为是值比较，故而在一些情况下会自动做类型转换再比较。也就是常说的js隐式转换。
===比较时，就是类型和值的比较了
ps:=== 运算符（和== 运算符）将数字值 -0 和 +0 视为相等，并认为 Number.NaN 不等于 NaN。
Object.is
    两个值都是 undefined
    两个值都是 null
    两个值都是 true 或者都是 false
    两个值是由相同个数的字符按照相同的顺序组成的字符串
    两个值指向同一个对象
    两个值都是数字并且
    都是正零 +0
    都是负零 -0
    都是 NaN
    都是除零和 NaN 外的其它同一个数字
    
### this
1.判断this的绑定：new,call/apply/bind,对象调用，默认绑定
2.使用new调用函数发生构造函数调用时，执行以下操作
创建一个全新的对象--->这个新对象会被执行prototype链接--->这个新对象会绑定到函数调用的this--->如果函数中没有返回其他的对象，那么new表达式中的函数调用会自动返回这个新对象
3.apply,call,bind的区别

    // call
    // 传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 thisArgs.func(...args)
 
    Function.prototype.call = function(thisArg, args) {
        // this指向调用call的对象
        if (typeof this !== 'function') { // 调用call的若不是函数则报错
            throw new TypeError('Error')
        }
        thisArg = thisArg || window
        thisArg.fn = this   // 将调用call函数的对象添加到thisArg的属性中
        const result = thisArg.fn(...[...arguments].slice(1)) // 执行该属性
        delete thisArg.fn   // 删除该属性
        return result
    }
    
    // bind
    Function.prototype.bind2 = function (context) {
        if (typeof this !== "function") {
          throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
        }
        var self = this;
        var args = Array.prototype.slice.call(arguments, 1);
        
        var fBound = function () {
            var bindArgs = Array.prototype.slice.call(arguments);
            return self.apply(
                this instanceof fNOP ? this : context, 
                args.concat(bindArgs)
            );
        }
        fBound.prototype = Object.create(this.prototype);
        return fBound;
    }
        
### 闭包
定义：定义在函数内部的函数，函数内部持有外部变量的引用
用途：读取函数内部的变量；让变量一直存储，不会被回收；方便调用上下文的局部变量，利于封装；模块模式，可以定义私有的变量函数，同时也可以提供给外部api；
### 继承
- 原型链继承


    function Father() {
        this.color = ['color1','color2']
    }
    Father.prototype.getColor = function () {
        return this.color
    }
    function Son() {
    
    }
    
    Son.prototype = new Father()
    
    let instance = new Son()
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    
    let instance2 = new Son()
    console.log(instance2.color) // ['color1','color2','color3']
    
    let instance3 = new Father()
    
    console.log(instance3.color) // ['color1','color2']
    
问题:如果是包含引用类型的原型属性会被所有实例共享；创建子类型的实例，不能向父类型的构造函数中传参

- 借用构造函数继承


    function Father() {
        this.color = ['color1','color2']
    }
    function Son() {
        Father.call(this) // 在子类型中调用父类型的构造函数，每一个实例创建的时候都会走到这里，相当与每个实例都有一个color的副本
    }
    
    let instance = new Son()
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    
    let instance2 = new Son()
    console.log(instance2.color) // ['color1','color2']
    
    let instance3 = new Father()
    console.log(instance3.color) // ['color1','color2']
    
问题:没啥复用性了，所有的东西都放构造函数里了

- 组合继承


    function Father(name) {
        this.name = name
        this.color = ['color1','color2']
    }
    Father.prototype.sayName = function () {
        console.log(this.name)
    }
    function Son(name,age) {
        Father.call(this,name)
        this.age = age
    }
    Son.prototype = new Father()
    Son.prototype.sayAge = function () {
        console.log(this.age)
    }
    
    let instance = new Son('wangyuqing','23')
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    instance.sayName()
    instance.sayAge()
    
    let instance2 = new Son('chenjun',25)
    console.log(instance2.color) // ['color1','color2','color3']
    instance2.sayName()
    instance2.sayAge()
    
解决了原型链和借用构造函数的缺点

- 原型式继承


    let person = {
       name:'person',
       family:['mother','me']
    }
    let person1 = Object.create(person)
    person1.name = 'person1'
    person1.family.push('father')
    console.log(person1.name)
    console.log(person1.family)
    
    let person2 = Object.create(person)
    person2.name = 'person2'
    console.log(person2.name)
    console.log(person2.family)
    
    console.log(person.name)

问题：和原型链继承一样，实例会对引用类型的属性进行共享

- 寄生式继承


    function creatAnthor(data){
        let clone = Object.create(data)
        clone.sayHi = function () {
            console.log('hi')
        }
        return clone
    }
    let person = {
        name:'person',
        family:['mother','me']
    }
    let person1 = creatAnthor(person)
    person1.sayHi()
    person1.name = 'person1'
    person1.family.push('father')
    console.log(person1.name)
    console.log(person1.family)
    
    let person2 = creatAnthor(person)
    person2.name = 'person2'
    person2.sayHi()
    console.log(person2.name)
    console.log(person2.family)
    
问题：和原型式继承基本一样，只是封装了一个方法返回了一个新对象，这个对象不仅有原来的data的属性和方法，还有自己的方法。其实就是在原型式继承上增强一下。与构造函数模式类似，会有做不到复用的情况。

- 重中之重：寄生组合式继承

    
    function Father(name) {
        this.name = name
        this.color = ['color1','color2']
    }
    Father.prototype.sayName = function () {
        console.log(this.name)
    }
    function Son(name,age) {
        Father.call(this,name)
        this.age = age
    }
    
    // Son.prototype = new Father()  组合继承的实现，会执行两次父类构造函数
    // -----新增-----
    // 其实就是把父类的原型指给子类的原型，但因为怕只想原型的过程中constructor丢失，就手动指一下
    let prototype = Object.create(Father.prototype) // 创建对象
    prototype.constructor = Son // 增强对象
    Son.prototype = prototype // 指定对象
    
    Son.prototype.sayAge = function () {
        console.log(this.age)
    }
    
    let instance = new Son('wangyuqing','23')
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    instance.sayName()
    instance.sayAge()
    
    let instance2 = new Son('chenjun',25)
    console.log(instance2.color) // ['color1','color2','color3']
    instance2.sayName()
    instance2.sayAge()

解决了执行两次父类构造函数的问题
### 原型
    function Foo() {...};
    let f1 = new Foo();

以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示：
![1](/image/原型链/1.png)
①__proto__和constructor属性是对象所独有的；
② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。
__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。
constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。
### 模块
- commonjs
一个文件就是一个模块，拥有独立作用于。
一个文件就是一个模块，拥有独立作用于。
- AMD规范
崇依赖前置，在定义模块的时候就要声明其依赖的模块,JS可以方便知道依赖模块是谁，立即加载
所有的模块都进行异步加载，模块加载不影响后面语句运行。
所有依赖某些模块的语句均放置在回调函数中。
提供全局define 函数（方法）来定义模块，require引入模块，exports导出模块。
- CMD规范
推崇就近依赖，只有在用到某个模块的时候再去require,需要使用把模块变为字符串解析一遍才知道依赖了那些模块。
### ajax
1.创建异步对象
    
    var xhr = new XMLHttpRequest();
2.设置请求行open(请求方式，请求url):

    // get请求如果有参数就需要在url后面拼接参数，
    // post如果有参数，就在请求体中传递 
    xhr.open("get","validate.php?username="+name)
    xhr.open("post","validate.php");

3.设置请求（GET方式忽略此步骤）头:setRequestHeader()

    // 1.get不需要设置
    // 2.post需要设置请求头：Content-Type:application/x-www-form-urlencoded
    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
    
4.设置请求体 send()
    
    // 1.get的参数在url拼接了，所以不需要在这个函数中设置
    // 2.post的参数在这个函数中设置(如果有参数)
    xhr.send(null) 
    xhr.send("username="+name);
    
5.让异步对象接收服务器的响应数据

    xhr.onreadystatechange = function(){ 
    if(xhr.status == 200 && xhr.readyState == 4){ 
        console.log(xhr.responseText);
    }
    
readyState   
0：请求未初始化，还没有调用 open()。
1：请求已经建立，但是还没有发送，还没有调用 send()。
2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。
3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。
4：响应已完成；您可以获取并使用服务器的响应了。
    
    
## VUE
### vue响应式原理
![1](/image/前端面试题集/1.jpg) 
Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新
Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。
Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种。watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。
compile : 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，
### computed原理(computed-watcher)
computed 本质是一个惰性求值的观察者。
computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。
其内部通过 this.dirty 属性标记计算属性是否需要重新求值。
computed中初始化对各个属性生成的watcher的dirty和lazy都设置为了true
当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,
computed watcher 通过 this.dep.subs.length 判断有没有订阅者,
有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)
在一次依赖收集期间，如果有其他依赖收集任务开始（比如：当前 computed 计算属性嵌套其他 computed 计算属性），那么将会把当前 target 暂存到 targetStack，先进行其他 target 的依赖收集，当嵌套的依赖收集任务完成后，将 target 恢复为上一层的 Watcher，并继续做依赖收集

    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Hello'
      },
      computed: {
        // 计算属性的 getter
        reversedMessage: function () {
          // `this` 指向 vm 实例
          return this.message.split('').reverse().join()
        }
      }
    })
    vm.reversedMessage // =>  olleH
    vm.message = 'World' // 
    vm.reversedMessage // =>  dlroW
    
    1.初始化 data和computed,分别代理其set以及get方法, 对data中的所有属性生成唯一的dep实例。
    2.对computed中的reversedMessage生成唯一watcher,并保存在vm._computedWatchers中
    3.访问 reversedMessage，设置Dep.target指向reversedMessage的watcher,调用该属性具体方法reversedMessage。
    4.方法中访问this.message，即会调用this.message代理的get方法，将this.message的dep加入reversedMessage的watcher,同时该dep中的subs添加这个watcher
    5.设置vm.message = 'World'，调用message代理的set方法触发dep的notify方法'
    6.因为是computed属性，只是将watcher中的dirty设置为true
    7.最后一步vm.reversedMessage，访问其get方法时，得知reversedMessage的watcher.dirty为true,调用watcher.evaluate()方法获取新的值。
    
### watcher原理（user-watcher）
其实就是对watch的一种封装，不是数组直接使用watcher，是数组的话遍历所有数组，将每一项使用watcher包装。
参数immediate就以当前值立即执行一次回调函数
参数deep如果为true，其实就是增加一步，在Dep.target = null 前，递归的对它的子值进行依赖收集。
考虑到watch可能也会对一个函数进行监听，watcher会同时对这个函数里面依赖的响应式数据进行监听，this.getter = expOrFun
### vm.$set()实现原理
1.如果是数组的话，通过splice自动来触发响应
2.如果目标元素已经存在，说明已经是响应式数据了，直接改变值就行了
3.处理新增属性，如果target上有_ob_证明他是被监测的，直接调用definedReactive();ob.dep.notify()就行了;如果没有ob,直接更改值就行了

    export function set(target: Array<any> | Object, key: any, val: any): any {
        // target 为数组  
        if (Array.isArray(target) && isValidArrayIndex(key)) {
            // 修改数组的长度, 避免索引>数组长度导致splice()执行有误
            target.length = Math.max(target.length, key);
            // 利用数组的splice变异方法触发响应式
            target.splice(key, 1, val);
            return val;
        }
        // target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值
        if (key in target && !(key in Object.prototype)) {
            target[key] = val;
            return val;
        }
        // 以上都不成立, 即开始给target创建一个全新的属性  // 获取Observer实例 
        const ob = (target: any).__ob__;
        // target 本身就不是响应式数据, 直接赋值 
        if (!ob) {
            target[key] = val;
            return val;
        }
        // 进行响应式处理 
        defineReactive(ob.value, key, val);
        ob.dep.notify();
        return val;
    }
       
### $on,$off,$emit,$once原理
    
    class Vue {
        constructor() {
            this._events = Object.create(null);
        }
    
        // 注册事件时，将回调函数收集起来，在触发函数时将收集起来的回调挨个触发一遍
        $on(event, fn) {
            if (Array.isArray(event)) {
                event.map(item => {
                    this.$on(item, fn);
                });
            } else {
                (this._events[event] || (this._events[event] = [])).push(fn);
            }
            return this;
        }
        // 只执行一次，所以思路就是通过$on监听，监听完了就用off把他删掉，手动触发一下回调即可。
        $once(event, fn) {
            function on() {
                this.$off(event, on);
                fn.apply(this, arguments);
            }
    
            on.fn = fn;
            this.$on(event, on);
            return this;
        }
        // 移除监听器
        $off(event, fn) {
            // 移除所有的监听器
            if (!arguments.length) {
                this._events = Object.create(null);
                return this;
            }
            // 数组的情况下，每一项都移除一遍
            if (Array.isArray(event)) {
                event.map(item => {
                    this.$off(item, fn);
                });
                return this;
            }
            // 只提供事件，没提供具体的回调，那就把这个事件的所有监听删除
            const cbs = this._events[event];
            if (!cbs) {
                return this;
            }
            if (!fn) {
                this._events[event] = null;
                return this;
            }
            // 最后一种情况，参数都齐了，循环监听器数组，找到一样的，删掉
            let cb;
            let i = cbs.length;
                // 从后向前遍历。因为是删除元素，如果从前往后遍历，会遇到条过一个元素的情况
            while (i--) {
                cb = cbs[i];
                if (cb === fn || cb.fn === fn) {
                    cbs.splice(i, 1);
                    break;
                }
            }
            return this;
        }
        // 拿到事件监听的数组，循环数组，将参数传入回调函数中，依次触发。
        $emit(event) {
            let cbs = this._events[event];
            if (cbs) {
                const args = [].slice.call(arguments, 1);
                cbs.map(item => {
                    args ? item.apply(this, args) : item.call(this);
                });
            }
            return this;
        }
    }
### v-model实现的原理
语法糖：

<Hello v-model="name"/> 解析为
<Hello :value="name" @change="data => name = data"/>

<input v-model="name"/> 解析为
<input :value="name" @input="name = $event.target.value">
### vue生命周期
![2](/image/前端面试题集/2.jpg) 
### keep-alive原理
获取 keep-alive 包裹着的第一个子组件对象及其组件名
根据设定的 include/exclude（如果有）进行条件匹配,决定是否缓存。不匹配,直接返回组件实例
根据组件 ID 和 tag 生成缓存 Key,并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关键)
在 this.cache 对象中存储该组件实例并保存 key 值,之后检查缓存的实例数量是否超过 max 的设置值,超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为 0 的那个 key）
最后组件实例的 keepAlive 属性设置为 true,这个在渲染和执行被包裹组件的钩子函数会用到,这里不细说
### new Vue()实例中,data 可以直接是一个对象,为什么在 vue 组件中,data 必须是一个函数呢?
因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。
所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。
### vue如何对数组进行重写监听的
简单来说,Vue 通过原型拦截的方式重写了数组的 7 个方法，首先获取到这个数组的ob,也就是它的 Observer 对象,如果有新的值,就调用 observeArray 对新的值进行监听,然后手动调用 notify,通知 render watcher,执行 update

    const arrayProto = Array.prototype;
    export const arrayMethods = Object.create(arrayProto);
    const methodsToPatch = [  "push",  "pop",  "shift",  "unshift",  "splice",  "sort",  "reverse"];
    /** * Intercept mutating methods and emit events */
    methodsToPatch.forEach(function(method) {  
    // cache original method  
    const original = arrayProto[method];  
        def(arrayMethods, method, function mutator(...args) {    
            const result = original.apply(this, args);    
            const ob = this.__ob__;    
            let inserted;    
            switch (method) {      
                case "push":      
                case "unshift":        
                    inserted = args;        
                    break;      
                case "splice":        
                    inserted = args.slice(2);        
                    break;    
            }    
            if (inserted) ob.observeArray(inserted);    
            // notify change    
            ob.dep.notify();    
            return result;  
        });
    });
    /** * Observe a list of Array items. */
    Observer.prototype.observeArray = function observeArray(items) {  
        for (var i = 0, l = items.length; i < l; i++) {   
            observe(items[i]);  
        }
    };
    
    
### watch和computed的区别
computed是计算属性，类似与过滤器，对绑定在view上的数据进行处理，computed的属性不能在data里赋值,具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数
watch是一个观察动作，可以通过deep:true来进行深度监听。打印oldVal和newVal值一样的原因是它们索引同一个对象/数组，Vue 不会保留修改之前值的副本，深度监听的函数必须是handler，因为watcher里面对应的是对handler的调用.无缓存性，页面重新渲染时值不变化也会执行
    
     watch:{
          secondChange:{
            handler(oldVal,newVal){
              console.log(oldVal)
              console.log(newVal)
            },
            deep:true
          }
        },

监听对象单个属性

    // 方法一：可以直接对用对象.属性的方法拿到属性
    data(){
      return{
        'first':{
          second:0
        }
      }
    },
    watch:{
      first.second:function(newVal,oldVal){
        console.log(newVal,oldVal);
      }
    }
    
    // 方法二：watch如果想要监听对象的单个属性的变化,必须用computed作为中间件转化,因为computed可以取到对应的属性值
    data(){
      return{
        'first':{
          second:0
        }
      }
    },
    computed:{
      secondChange(){
        return this.first.second
      }
    },
    watch:{
      secondChange(){
        console.log('second属性值变化了')
      }
    },
               
### 过滤器


    <!-- 在双花括号中 -->
    {{ message | capitalize }}
    
    <!-- 在 `v-bind` 中 -->
    <div v-bind:id="rawId | formatId"></div>
    
    filters: {
      capitalize: function (value) {
        if (!value) return ''
        value = value.toString()
        return value.charAt(0).toUpperCase() + value.slice(1)
      }
    }
    
    
### 父子组件的通讯
父子组件通信: props; $parent / $children; provide / inject ; ref ; $attrs / $listeners
兄弟组件通信: eventBus ; vuex
跨级通信: eventBus；Vuex；provide / inject 、$attrs / $listeners
### localstorage怎么监听
同源的不同页面，监听事件就行了

    window.addEventListener("storage", function (e) {
            console.log(e.newValue);
    });
同页面，对 localStorage 的 setItem 方法进行重写
    
    var orignalSetItem = localStorage.setItem;
    localStorage.setItem = function(key,newValue){
          var setItemEvent = new Event("setItemEvent");
          setItemEvent.key = key;
          setItemEvent.newValue = newValue;
          window.dispatchEvent(setItemEvent);
          orignalSetItem.apply(this,arguments);
    }
    window.addEventListener("setItemEvent", function (e) {
        console.log(e.newValue);
    });
    localStorage.setItem("name","wang");

在vue中

    /**
     * @param { number } type 1 localStorage 2 sessionStorage
     * @param { string } key 键
     * @param { string } data 要存储的数据
     * @returns 
     */
    // 如果报prototype无法被识别的错误，可以把原型方法挂在到__proto__
    Vue.prototype.$addStorageEvent = function (type, key, data) {
        if (type === 1) {
            // 创建一个StorageEvent事件
            var newStorageEvent = document.createEvent('StorageEvent');
            const storage = {
                setItem: function (k, val) {
                    localStorage.setItem(k, val);
                    // 初始化创建的事件
                    newStorageEvent.initStorageEvent('setItem', false, false, k, null, val, null, null);
                    // 派发对象
                    window.dispatchEvent(newStorageEvent);
                }
            }
            return storage.setItem(key, data);
        } else {
            // 创建一个StorageEvent事件
            var newStorageEvent = document.createEvent('StorageEvent');
            const storage = {
                setItem: function (k, val) {
                    sessionStorage.setItem(k, val);
                    // 初始化创建的事件
                    newStorageEvent.initStorageEvent('setItem', false, false, k, null, val, null, null);
                    // 派发对象
                    window.dispatchEvent(newStorageEvent);
                }
            }
            return storage.setItem(key, data);
        }
    }
    二、组件中调用：
    
    this.$addStorageEvent(2, "user_info", data);
    三、在另一个组件中的 mounted 钩子函数中监听：
    
    window.addEventListener('setItem', (e) => {
      //获取参数
         console.log(e);
    });
    
### 组件的类别
全局组件和局部组件
全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。
### vue-router实现路由懒加载

1.import按需加载（官方写法）

    const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')

2.vue异步组件

    {
        path: '/path',
        name: 'componentName',
        component: resolve => require(['@/componentPath'], resolve),
    }
      
### 动态加载路由

    const router = new Router({
      routes: [
        {path: '/', redirect: '/home'},
      ]  
    })
     
    router.addRoutes([
      {
        path: '/login',
        name: 'login',
        component: () => import('../components/Login.vue')
      }
    ])
### 路由守卫
全局前置守卫 beforeEach(to,from,next)
全局后置守卫 afterEach(to,from)
路由守卫 beforeEnter(to, from, next)
组件内守卫 beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave

完整的导航解析流程
1.导航被触发。
2.在失活的组件里调用 beforeRouteLeave 守卫。
3.调用全局的 beforeEach 守卫。
4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5.在路由配置里调用 beforeEnter。
6.解析异步路由组件。
7.在被激活的组件里调用 beforeRouteEnter。
8.调用全局的 beforeResolve 守卫 (2.5+)。
9.导航被确认。
10.调用全局的 afterEach 钩子。
11.触发 DOM 更新。
12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
### vue的频繁变化为什么只变化一次
### 自定义指令
### axios请求封装，拦截器，原理

## VUEX
1.vuex流程
![1](https://vuex.vuejs.org/vuex.png) 
在vue组件里面，通过dispatch来触发actions提交修改数据的操作。
然后再通过actions的commit来触发mutations来修改数据。
mutations接收到commit的请求，就会自动通过Mutate来修改state（数据中心里面的数据状态）里面的数据。
最后由store触发每一个调用它的组件的更新
2.核心概念
- state是存储的单一状态，是存储的基本数据。
- Getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。
- Mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）
- Actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）
- Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。
3.vuex原理
![2](http://img1.sycdn.imooc.com/5d5813ab0001a8b910021104.png) 
    
    
    // src/store.js
    function resetStoreVM (store, state, hot) {
      // 省略无关代码
      Vue.config.silent = true
      store._vm = new Vue({
        data: {
          $$state: state
        },
        computed
      })
    }
    
beforeCreate生命周期注入了设置this.$store这样一个对象
其本质就是将我们传入的state作为一个隐藏的vue组件的data,也就是说，我们的commit操作，本质上其实是修改这个组件的data值，结合上文的computed,修改被defineReactive代理的对象值后，会将其收集到的依赖的watcher中的dirty设置为true,等到下一次访问该watcher中的值后重新获取最新值。
这样就能解释了为什么vuex中的state的对象属性必须提前定义好，如果该state中途增加一个属性，因为该属性没有被defineReactive，所以其依赖系统没有检测到，自然不能更新
2.computed和vuex里的getter有什么区别
3.vuex里的getter和mutation有什么区别

## REACT

- react的生命周期
- setState有时候是同步的？异步？批量更新
- 组件的类型，如何创建组件
- redux原理，流程
- 热更新

## WEBPACK
### 什么是webpack
webpack是一个打包工具，他的宗旨是一切静态资源皆可打包。规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。
### webpack核心概念
1.Entry（入口）：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
2.Output（出口）：告诉 webpack 在哪里输出它所创建的结果文件，以及如何命名这些文件，默认值为./dist。
3.Loader（模块转换器）：将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。
4.Plugins（插件）：在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。
5.Module(模块)：开发者将程序分解成离散功能块，并称之为模块，在webpack里一个模块对应着一个文件，webpack会从配置的 Entry 开始递归找出所有依赖的模块。
### webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全
webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，每找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑
Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：
初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
确定入口：根据配置中的 entry 找出所有的入口文件；
编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。
### Webpack与Grunt和Gulp的区别
Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。
Grunt和Gulp的工作方式是：基于任务和流（Task、Stream）的，在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。
gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系。webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工
### loader
1.什么是loader
Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力
2.常见的locader
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去
source-map-loader：加载额外的 Source Map 文件，以方便断点调试
image-loader：加载并且压缩图片文件
babel-loader：把 ES6 转换成 ES5
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
eslint-loader：通过 ESLint 检查 JavaScript 代码
3.loader原理
loader的执行顺序和代码书写的顺序是相反的，即：最后一个loader最先执行，第一个loader最后执行
第一个执行的loader会接收源文件做为参数，下一次执行的loader会接收前一个loader执行的返回值做为参数
单一原则: 每个 Loader 只做一件事；
链式调用: Webpack 会按顺序链式调用每个 Loader；
统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；
4.写一个loader
    
    // webpack.config.js
    rules: [
      {
        test: /\.txt$/,
        use: [
          './loaders/myloader2.js','./loaders/myloader1.js'
        ]
      }
    ]
    // loaders/myloader1.js    
    module.exports = function (src) {
        src = src.split('').reverse().join('')
        return src;
    }
    // loaders/myloader2.js   
    module.exports = function(source) {
      // 通过 this.callback 告诉 Webpack 返回的结果
      // 其中的this.callback是Webpack给Loader注入的API，以方便Loader和Webpack之间通信。
      this.callback(null, source, sourceMaps);
      // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，
      // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 
      return;
    };
    
### Plugin
1.常见的Plugin
define-plugin：定义环境变量
HtmlWebpackPlugin:可以生成创建html入口文件,为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题
uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码，删除警告
CleanWebpackPlugin：清除打包的文件
HotModuleReplacementPlugin：热重载（更新的模块重载）
2.plugin的原理
plugin 本质上就是一个类,有一个 apply 方法，接受一个 compiler 的对象, 我们会在 compiler 对象上钩子挂载一些监听函数，当 compiler 对象上这些钩子触发的时候，就会调用这些函数。Webpack启动后，在读取配置的过程中会先执行new BasicPlugin(options)初始化一个BasicPlugin获得其实例。 在初始化compiler对象后，再调用basicPlugin.apply(compiler)给插件实例传入compiler对象。 插件实例在获取到compiler对象后，就可以通过compiler.plugin(事件名称, 回调函数)监听到Webpack广播出来的事件。 并且可以通过compiler对象去操作Webpack。
3.写一个plugin
    
    // BasicPlugin.js
    class BasicPlugin{
      // 在构造函数中获取用户给该插件传入的配置
      constructor(options){
      
      }
    
      // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象
      apply(compiler){
        compiler.plugin('compilation',function(compilation) {
        
        })
      }
    }
    // 导出 Plugin
    module.exports = BasicPlugin;
    
    
    // webpack.config.js
    const BasicPlugin = require('./BasicPlugin.js');
    module.export = {
      plugins:[
        new BasicPlugin(options),
      ]
    }
    
### 用 webpack 实现 long term cache
思路：哪个模块更新了破坏他的缓存，没更新的模块继续利用缓存。 
1.code splitting

    // 1.多entry方式
    entry: {
        a: './code_split_mode/a.js',
        b: './code_split_mode/b.js'
    },
    // 2.公共提取,拆分代码配置项方式
    optimization: {
        splitChunks: {
          cacheGroups: {
            node_vendors: {
              test: /[\\/]node_modules[\\/]/,
              chunks: 'async',
              priority: 1
            }
          }
        }
    },
    // 3.动态加载
    output: {
      path: config.build.assetsRoot,
      filename: utils.assetsPath('js/[name].[chunkhash].js'),
      chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
    },
    // 4.动态加载在vue中
    // 把每个路由所包含的组件，都分割成一个单独的 bundle（通过import()就已经可以实现了）；当路由被访问的时候才加载该路由对应的 bundle（ue 允许将组件定义为一个工厂函数，异步地解析组件的定义。只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。在工厂函数中可以返回 Promise，而 import() 也是返回 Promise 的，这样就把异步组件和 import() 结合起来了。）
    const router = new VueRouter({
      routes: [
        { path: '/login', component: () => import('@/views/login'), },
        { path: '/home', component: () => import('@/views/home'), }
      ]
    })
      
2.生成稳定的 hash 文件名
    
      output: {
        //...
        filename: '[name].[chunkhash:8].js',
        chunkFilename: '[name].[chunkhash:8].chunk.js',
        //...
      },
    }
    
3.提取 webpack 的 runtime 代码（用来解析和加载模块之类的运行时代码）
    
    new webpack.optimize.CommonsChunkPlugin({ 
      name: ['manifast'] 
    }),
    
4.保持moudule的id
webpack 里每个模块都有一个 module id ，module id 是该模块在模块依赖关系图里按顺序分配的序号，如果这个 module id 发生了变化，那么他的 chunkhash 也会发生变化。
    
    plugins: [
      new webpack.HashedModuleIdsPlugin(),
      // ...
    ],
### 使用webpack优化体积
1.mini-css-extract-plugin提取css
2.new OptimizeCSSAssetsPlugin()压缩css
3.cdn
4.splitChunks
>提取webpack的runtime代码到单独manifest的文件
 所有静态依赖第三方库被分割到同一个文件中,通过cacheGroup
 多入口情况下：被多次引用的自研发模块统一放到一个文件中，便于多个入口共享，整一个common
 配置缓存，new webpack.HashedModuleIdsPlugin()
 多入口情况下：在new HtmlWebpackPlugin下的chunks写如对应页面的引用模块名字
 
5.路由按需加载（webpackchunkname）
    
    
    
    
## 优化

### 函数防抖和节流有什么特点，区别，场景
防抖，只最后一次执行。可以在input输入内容发起请求的时候用
节流，定时执行，可以在滚动的时候触发
### 网页崩溃怎么排查，常见的原因
抓包，查询日志
原因：频繁操作dom,死循环
### 页面的加载时间（工具，各项指标）
1.通过谷歌浏览器开发者工具看各个资源加载的情况
2.DOMContentLoaded/load

        console.log('观察脚本加载的顺序')
        // 页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件，简单来说，页面的load事件会在DOMContentLoaded被触发之后才触发
        window.addEventListener("load", function() {
            let a = document.getElementById('a')
            console.log('load事件回调')
        }, false);
        // 当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等位于脚本前面的css加载完才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。
        document.addEventListener("DOMContentLoaded", function() {
            let a = document.getElementById('a')
            console.log('DOMContentLoaded回调') // 不兼容老的浏览器，兼容写法见[jQuery中ready与load事件] ，原理看下文
        }, false);
    
    
3.通过window.performance.timing
DNS查询耗时 ：domainLookupEnd - domainLookupStart
TCP链接耗时 ：connectEnd - connectStart
request请求耗时 ：responseEnd - responseStart
解析dom树耗时 ： domComplete- domInteractive
白屏时间 ：responseStart - navigationStart
domready时间 ：domContentLoadedEventEnd - navigationStart
onload时间 ：loadEventEnd - navigationStart
### 不同设备版本的兼容性
1.audio元素和video元素在ios和andriod中无法自动播放
原因： 因为各大浏览器都为了节省流量，做出了优化，在用户没有行为动作时（交互）不予许自动播放；

    /音频，写法一
    <audio src="music/bg.mp3" autoplay loop controls>你的浏览器还不支持哦</audio>
    
    //音频，写法二
    <audio controls="controls"> 
        <source src="music/bg.ogg" type="audio/ogg"></source>
        <source src="music/bg.mp3" type="audio/mpeg"></source>
        优先播放音乐bg.ogg，不支持在播放bg.mp3
    </audio>
    
    //JS绑定自动播放（操作window时，播放音乐）
    $(window).one('touchstart', function(){
        music.play();
    })
    
    //微信下兼容处理
    document.addEventListener("WeixinJSBridgeReady", function () {
        music.play();
    }, false);
    
    //小结
    //1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常；
    //2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间；
    //3.注意不要遗漏微信的兼容处理需要引用微信JS；
2.上传图片，iPhone7 iPhone7p在上传图片的时候，传不过去图片的name
手动添加图片name

    let data = new FormData();
    data.append("fileName", file[0],file[0].name);     

3.ios如果有fixed布局，滚动时底部定位的没了

    -webkit-overflow-scrolling:touch // 回弹效果，有fiexd不能设置
    -webkit-overflow-scrolling:auto // 无回弹效果

4.ios12虚拟键盘收起的时候，键盘区域留白问题
    
    handleblur() {
         window.scrollTo(0, 0);
    }
5.ios输入英文会有空格
    
    this.value = this.value.replace(/\u2006/g,'');

6.ie10不兼容vue-echar，改成eachar
    
    
### 前端优化具体的做法

- http层面优化

浏览器并发
基于端口跟线程切换开销，浏览器不可能无限的并发请求。chrome的并发为6，超过限制数目的请求就会被阻塞

http请求次数
减少http的请求次数，将多个请求合并成同一个，减少http的开销

减少cookie
coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。

所以对首屏的接口进行整合，减少不必要的接口请求。css/js合并打包

- 资源优化

图片优化
jpeg/jpg:体积小，有损压缩，一般背景图，轮播图会用得到，缺点不支持透明，压缩过后有些图片会模糊
png:无损压缩，支持透明，小logo并且颜色丰富的时候会用到，但是它体积较大
svg:无限放大不失真，体积更小，压缩性更强，兼容性好，但渲染成本高
base64:编码，可减少请求次数，非常小的小icon,但base64编码后，图片会膨胀为原来大小的3/4
按照需求选择更适合的图片
同时避免image标签的src为空，因为浏览器加载到image标签发现它空，就会以为自己没加载到，会再次请求一遍。

体积优化
压缩静态资源：合并打包的js、css文件体积一般会比较大，一些图片也会比较大，这个时候必须要压缩处理。
编写高效率的CSS：减少深层次嵌套，减少元素选择器使用等等

资源加载优化
浏览器对同域名并发请求是有数量限制一般是6个，所以考虑到静态资源部署cdn
按需加载，同域名内的文件充分的进行压缩

- 渲染优化

懒加载
最常见的场景是在图片的懒加载中，先用一种loading的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。

动态加载
动态加载脚本就是利用javascript代码来加载脚本，通常是手工创建script元素，然后等到HTML文档解析完毕后插入到文档中去。这样就可以很好地控制脚本加载的时机，从而避免阻塞问题。


    function loadJS(src) {
      const script = document.createElement('script');
      script.src = src;
      document.getElementsByTagName('head')[0].appendChild(script);
    }
    loadJS('http://example.com/scq000.js');
 
未来所需组件预加载
 
减少重排重绘
当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。
简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘，但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。
触发重排和重绘的情况：
添加、删除、更新 DOM 节点
display: none 隐藏一个 DOM 节点-触发重排和重绘
通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化
移动或者给页面中的 DOM 节点添加动画
添加一个样式表，调整样式属性
用户行为，例如调整窗口大小，改变字号，或者滚动。
解决方法：
让该元素脱离文档流->对其进行多重改变->将元素带回文档中

- 打包优化
mini-css-extract-plugin提取css
new OptimizeCSSAssetsPlugin()压缩css
cdn
splitChunks
>提取webpack的runtime代码到单独manifest的文件
 所有静态依赖第三方库被分割到同一个文件中,通过cacheGroup
 多入口情况下：被多次引用的自研发模块统一放到一个文件中，便于多个入口共享，整一个common
 配置缓存，new webpack.HashedModuleIdsPlugin()
 多入口情况下：在new HtmlWebpackPlugin下的chunks写如对应页面的引用模块名字
 
5.路由按需加载（webpackchunkname）
    
    
## 安全
### CSRF攻击
CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。
CSRF攻击攻击原理及过程如下：
1.用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3.用户未退出网站A之前，或者说是本地cookie没有失效，在同一浏览器中，打开一个TAB页访问网站B；
4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

### XSS攻击
场景：想象一下 JSONP 就是你请求 http://youdomain.com?callback=douniwan, 然后返回 douniwan({ data })，那假如请求 http://youdomain.com?callback=<script>'console.log(1)'</script> 不就返回 <script>console.log(1)</script>({ data })了吗，如果没有严格定义好 Content-Type（ Content-Type: application/json ），再加上没有过滤 callback 参数，直接当 html 解析了，就是一个赤裸裸的 XSS 了。
原则：不相信客户输入的数据
解决方法
严格定义 Content-Type: application/json
然后严格过滤 callback 后的参数并且限制长度（进行字符转义，例如<换成&lt，>换成&gt）等，这样返回的脚本内容会变成文本格式，脚本将不会执行。
将重要的cookie标记为http only,这样的话Javascript 中的document.cookie语句就不能获取到cookie了.
只允许用户输入我们期望的数据。
过滤JavaScript 事件的标签。例如 "onclick=", "onfocus" 等等。

## 架构
### 前端工程化
模块化、组件化、规范化、自动化
1.模块化
模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。现有的es6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范。
webpack可以将文件打包成一个文件，也可以搭乘多个chunk,资源模块化
CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。
2.组件化
从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。
模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。
3.规范化
结构规范/编码规范/接口规范/文档规范/commit规范
4.自动化
webpack编译打包，实时刷新等等

## 项目
1.rn中转
    
    <script type="text/javascript">
        (function () {
          var UA = navigator && navigator.userAgent || "";
          var href = location && location.href || "";
            var skuId
            var search = location.search
            if (search) {
              var arr = search.match(/skuId=(\d*)/)
              if (arr) {
                skuId = arr[1]
              }
            }
            var param = ''
            if (skuId) {
              param = `,"skuId":"${skuId}"`
            }
            location.href = `openapp`
            document.addEventListener("visibilitychange", function () {
              if (!!UA.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/)) {
                location.href = 'closeApp://webview?refresh=true';
              } else {
                Android.finishWebActivity();
              }
            });
        })()
      </script>

