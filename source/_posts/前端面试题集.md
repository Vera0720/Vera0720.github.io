---
title: 前端面试题集
date: 2017-10-10 22:30:22
tags: 面试
---
按照分类整理了一波面试题，后续会慢慢补充答案的。

<!-- more -->

## 操作系统
### 进程和线程
进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

一个流程：程序A得到CPU => CPU加载上下文 => 开始执行程序A的a小段 => 然后执行A的b小段 => 然后再执行A的c小段 => 最后CPU保存A的上下文。这里a，b，c 的执行共享了A的上下文，CPU在执行的时候没有进行上下文切换的。

## HTTP

### http报文结构
报文一般包括了：通用头部，请求/响应头部，请求/响应体
通用头部:
    
    Request Url: 请求的web服务器地址
    
    Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）
    
    Status Code: 请求的返回状态码，如200代表成功
    
    Remote Address: 请求的远程服务器地址（会转为IP）
    
请求/响应头部

    请求头
    Accept: 接收类型，表示浏览器支持的MIME类型
    （对标服务端返回的Content-Type）
    Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
    Content-Type：客户端发送出去实体内容的类型
    Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
    If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
    Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
    Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
    If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
    Cookie: 有cookie并且同域访问时会自动带上
    Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
    Host：请求的服务器URL
    Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
    Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
    User-Agent：用户客户端的一些必要信息，如UA头部等
    
    响应头
    Access-Control-Allow-Headers: 服务器端允许的请求Headers
    Access-Control-Allow-Methods: 服务器端允许的请求方法
    Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
    Content-Type：服务端返回的实体内容的类型
    Date：数据从服务器发送的时间
    Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
    Last-Modified：请求资源的最后修改时间
    Expires：应该在什么时候认为文档已经过期,从而不再缓存它
    Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
    ETag：请求变量的实体标签的当前值
    Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
    Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
    Server：服务器的一些相关信息
    
ps:插一句cookie的交互
![5](/image/前端面试题集/5.jpg)
请求/响应实体
请求实体中会将一些需要的参数都放入进入（用于post请求），一般响应实体中，就是放服务端需要传给客户端的内容

### http缓存
强制缓存（200 from cache）（cache-control:max-age || Expries），对比缓存（304）(lastmodified && ETag)

If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内
If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。

![3](/image/输入url会发生什么/3.jpg)

浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）
F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since
Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作

html页面禁用缓存的设置如下：

    <meta http-equiv="pragma" content="no-cache">
    // 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求
    <meta http-equiv="cache-control" content="no-cache">
    // 其他主流浏览器识别的标签
    <meta http-equiv="expires" content="0">
    // 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段
    html设置缓存如下：
    <meta http-equiv="Cache-Control" content="max-age=7200" />
    // 其他主流浏览器识别的标签
    <meta http-equiv="Expires" content="Mon, 20 Aug 2018 23:00:00 GMT" />
    // 仅有IE浏览器才识别的标签

### 输入url发生什么

1.浏览器的地址栏输入url并按下回车，开启网络请求线程
浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程。进程可能包括主控进程（浏览器的主进程（负责协调、主控），只有一个），插件进程（每种类型的插件对应一个进程，仅当使用该插件时才创建），GPU（最多一个，用于3D绘制），浏览器渲染进程（默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等）等等
每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：GUI线程，JS引擎线程，事件触发线程，定时器线程，网络请求线程

2.浏览器查找当前url是否存在缓存，并比较缓存是否过期

3.DNS解析url对应的IP
首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。最后迭代查询，按根域服务器 ->顶级域（.cn）->第二层域（hb.cn） ->子域（ www.hb.cn ）的顺序找到IP地址。

4.根据IP建立TCP连接（三次握手）

5.服务器端处理（动态页面处理，静态页面返回。CDN相关）
一般有的后端是有统一的验证的，如安全拦截，跨域验证
如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）
然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
然后就是将这个包从后端发送到前端，完成交互
前后端交互时，http报文作为信息的载体

6.HTTP发起请求

7.服务器处理请求，浏览器接收HTTP响应

8.渲染页面，构建DOM树（收到HTML内容解析，并行加载串行执行执行CSS，js，普通图层和复合图层）
async 是并行下载，但阻止解析；defer是并行下载，等dom解析玩了再解析js

可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的
如果开启了硬件加速功能，可以将某个节点变成复合图层
复合图层之间的绘制互不干扰，由GPU直接控制
而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速

9.请求头内容缓存到浏览器端

10.关闭TCP连接，4次握手

### 五层因特尔协议栈

1.应用层(dns,http) DNS解析成IP并发送http请求
    
2.传输层(tcp,udp) 建立tcp连接（三次握手）

3.网络层(IP,ARP) IP寻址

4.数据链路层(PPP) 封装成帧

5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

### http1.0,2.0

#### 2.0
1.多路复用
HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？
HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
具体如图：

HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。
HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。
2.二进制分帧

### CDN原理
内容分发网络。原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。
![6](/image/前端面试题集/6.png)
1.用户在浏览器中输入要访问的域名。
2.浏览器向DNS服务器请求对域名进行解析。由于CDN对域名解析进行了调整，DNS服务器会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。
3.CDN的DNS服务器将CDN的负载均衡设备IP地址返回给用户。
4.用户向CDN的负载均衡设备发起内容URL访问请求。
5.CDN负载均衡设备会为用户选择一台合适的缓存服务器提供服务。
选择的依据包括：
根据用户IP地址，判断哪一台服务器距离用户最近；
根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；
查询各个服务器的负载情况，判断哪一台服务器的负载较小。
基于以上这些依据的综合分析之后，负载均衡设置会把缓存服务器的IP地址返回给用户。
6.用户向缓存服务器发出请求。
7.缓存服务器响应用户请求，将用户所需内容传送到用户。
8.如果这台缓存服务器上并没有用户想要的内容，而负载均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉取到本地。

### DNS
#### DNS解析
首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。
如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。
如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。
最后迭代查询，按根域服务器 ->顶级域（.cn）->第二层域（hb.cn） ->子域（ www.hb.cn ）的顺序找到IP地址。
本地DNS服务器缓存结果，返回给用户，缓存在系统中
#### Local DNS有什么缺陷
1.DNS劫持:DNS劫持会导致端上网络连接失败或者DNS解析失败
2.DNS解析过慢:递归查询和迭代查询两种
>递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步的查询。
迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：你下一步应当向哪一个域名服务器进行查询。然后让本地域名服务器进行后续的查询，而不是替本地域名服务器进行后续的查询。
递归模式会导致DNS服务器流量很大，所以现在大多数采用迭代模式。
#### DNS优化
1.DNS Prefetching（启动预解析）
    
    // html
    <meta http-equiv="x-dns-prefetch-control" content="on">
    // 对特定域名预解析
    <link rel=”dns-prefetch” href=”//fonts.googleapis.com”>
    // 服务器
    X-DNS-Prefetch-Control = on
    
2.HttpDns
安全，由于httpdns使用http或者https协议通过ip直连的方式进行解析，绕过了运营商的Local DNS，避免了域名劫持
快速，通过预解析机制，将热点域名提前解析，网络连接时直接缓存获取
## CSS

### 盒模型
> 标准盒模型及怪异盒模型，box-sizing:content-box/border-box

        // 标准盒模型，实际宽为200+1*2+10*2
        .content-box{
            box-sizing:content-box;
            width:200px;
            height:200px;
            border:1px solid #000;
            padding:10px;
        }
        // 怪异盒模型,实际宽为200（10*2+1*2+178）
        .content-box{
            box-sizing:border-box;
            width:200px;
            height:200px;
            border:1px solid #000;
            padding:10px;
            margin:10px;
        }
### flex
>弹性盒模型，不兼容ie9以下

        1.容器基本属性：
        - flex-direction(主轴方向的排列方法):row/row-reverse/column/column-reverse
        - flex-wrap: wrap/no-wrap/wrap-reverse
        - flex-flow: <flex-direction>  <flex-wrap>;
        - justify-content（项目在主轴上的对齐方式）: center/flex-start/flex-end/space-between/space-around
        - align-items（项目在交叉上的对齐方式）: center/flex-start/flex-end/baseline（项目的第一行文字的基线对齐）/stretch（如果项目未设置高度或设为auto，将占满整个容器的高度。）
        - align-content（定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用）: flex-start | flex-end | center | space-between | space-around | stretch
        2. 项目基本属性
        - order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。
        - flex-grow:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
        - flex-shrink:项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。0为原有大小
        - flex-basis: 在分配多余空间之前，项目占据的主轴空间 <length> | auto
        - flex:flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
        - align-self:单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。
### input的placeholder
>
        css选择:input::placeholder
        垂直居中:line-height: normal
    
### rem原理
>本质是等比缩放，一般是基于宽度。一般是通过两种方式来设置

        1.sass
        
        $width: 750; /* ui图的宽度 */
        
        @function px2rem($px) {
          @return #{$px/$width*100}rem;
        }
        
        p {
          width: px2rem(100);
        }
        
        2.head头里计算根结点字体大小
        
        window.onresize = function () {
            resetFontSize()
        };
        function resetFontSize() {
            document.documentElement.style.fontSize = document.documentElement.clientWidth / 3.75 + 'px';
        }
        resetFontSize()
### box-show
    
    box-shadow: h-shadow v-shadow blur(模糊距离) spread(阴影的大小) color inset;

单边阴影主要是改变阴影的大小，配合水平和垂直位移
### 水平垂直居中
>可以通过flex布局，position+margin/transform:translate(-50%,-50%)
### 动画
>animation/transition/transform

        // animation
        @keyframes actWith {
            from {
                background: red;
            }
            to{
                background: yellow;
            }
        }
        @keyframes actWith {
            10% {
                background: red;
            }
            50%{
                background: yellow;
            }
            100%{
                background: blue;
            }
        }
        div {
            animation: actWith 5s;          
            // animation: name duration timing-function（line,ease...） delay iteration-count direction fill-mode play-state;
        }
        
        // transition 需要事件的触发
        // transition: property duration timing-function delay;
        div{
            // transform  旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix
            transform:rotate(7deg);
        }
               
### 定位
>static(不同里文档流，默认)，relative(相对与原有本身位置，不脱离文档流)，absolute(相对非static已定位最近父元素,脱离文档流)，fixed(相对与当前浏览器窗口，脱离文档流)
### BFC
>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
        
        - 布局规则
        1.内部的Box会在垂直方向，一个接一个地放置。
        2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。   
        3.每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
        4.BFC的区域不会与float box重叠。
        5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
        - 如何创建BFC
        1.float非none
        2.position非statcic,relative
        3.overflow非visible
        4.display的值为table-call,inline-block,flex,table-caption,inline-flex
        
### margin折叠
>在CSS中，【两个或多个】 【毗邻】 的 【普通流】 中的盒子（可能是父子元素，也可能是兄弟元素）在 【垂直方向】 上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。
        
        .parent1 {
            width: 100px;
            height: 100px;
            background: yellow;
            margin-bottom: 20px;
        }
        .parent2 {
            width: 100px;
            height: 300px;
            margin-top: 30px;
            background: blue;
            margin-bottom: 30px;
        }
        .parent3 {
            width: 100px;
            height: 100px;
            background: green;
            margin-top: 50px;

        }
        .child {
            background: red;
            height: 20px;
            margin-top: 50px;
            margin-bottom: 60px;
        }
        .parent-2{
            width: 100px;
            height: 500px;
            background: black;
        }
        .child-2{
            width: 100px;
            height: 100px;
            margin-top: 50px;
            background: bisque;
        }
                
        <div class="parent1"></div>
        <div class="parent2">
            <div class="child"></div>
            <div class="child"></div>
            <div class="child"></div>
        </div>
        <div class="parent3"></div>
        <div class="parent-2">
            <div class="child-2"></div>
        </div>
            
            
### 让图文不可复制
user-select: none;
### 复制在粘贴板上加一段话
1、答案区域监听copy事件，并阻止这个事件的默认行为。
2、获取选中的内容（window.getSelection()）加上版权信息，然后设置到剪切板（clipboarddata.setData()）。

## Html
### DOM事件流
事件捕获，处于目标阶段，事件冒泡
通过addlisterner(fun,true/false)
e.target是事件触发的元素，event.currentTarget指向事件绑定的元素（就是冒泡啥的触发可用event.currentTarget来追踪）
### DOM0级事件与DOM2级事件
DOM0级事件就是找到这个元素，绑定他。取消事件就直接设为null就行了
DOM2级事件就是找到这个元素，监听他的事件。取消事件就直接removeaddListerner
### 浏览器渲染原理
1、构建DOM树
2、CSS标记，构成层叠样式表模型CSSOM
3、将DOM和CSSOM合并为渲染树(rendering tree)
4、渲染树布局，布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。
5、渲染树绘制

### 各种宽高
offsetTop：元素到offsetParent（距离元素最近的一个具有定位的祖宗元素或table, table cell 或body）顶部的距离
offsetHeight:不算border的高度
scrollHeight：算上内部元素本身高度的总高度，就是里面撑开了，即时看不见，也能计算到高度里
scrollTop:滚动条具体顶部的高度

## JS

### v8引擎了解么，一段js执行的时候发生了什么

1.js首先会创建一个执行栈
2.创建阶段：创建一个全局执行上下文，push到栈里，对所有变量分配内存附一个初始值
3.执行阶段：一行行执行代码，为初始化的变量赋真实的值
4.如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到执行栈中
5.有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。
6.当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。

### es6
#### es6的新增语法
let/const/promise/解构/filter/set/map
#### let与var的区别，为什么不能变量提升，重复复值，const为什么在有些情况下可以改变
let 的「创建」过程被提升了，但是初始化没有提升。
var 的「创建」和「初始化」都被提升了。
function 的「创建」「初始化」和「赋值」都被提升了。

如果let x = d ;抱错，x 变量就将永远处于 created 状态。
你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。
由于 x 无法被初始化，所以 x 永远处在暂时死区

let 声明会提升到块顶部
从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区）
如果你在 TDZ 内使用该变量，JS 就会报错

const是赋值本身不可变，对象的地址不可变，但可以对对象增加修改删除属性
### promise
#### promise的常用api
then,catch,resolve,reject,all,race
#### 如何实现一个带休眠的promise
直接在promise里写settimeout延迟2秒触发reject
新建一个定时任务，通过.race，让两个promise进行比较
#### 如何实现两个接口的链式调用
return一个promise用.then调用，也可以用async,await
#### 事件循环
#### promise原理
#### promise.all实现原理

    Promise.all = function (promise) {
        return new Promise((resolve, reject) => {
            let index = 0
            let result = []
            if (promise.length === 0) {
                resolve(result)
            } else {
                function processValue(i, data) {
                    result[i] = data
                    if (++index === promise.length) {
                        resolve(result)
                    }
                }
                for (let i = 0; i < promise.length; i++) {
                    Promise.resolve(promise[i]).then((data) => {
                        processValue(i, data)
                    }, (err) => {
                        reject(err)
                        return
                    })
                }
            }
        })
    }
#### promise.race原理

    function myPromiseRace(promiseArr){
        return new Promise((resolve,reject) => {
            if(!Array.isArray(promiseArr)) throw('参数必须为数组')
            let len = promiseArr.length
            for(let i = 0; i < len; i++){
                Promise.resolve(promiseArr[i]).then(val => {
                    resolve(val)
                }).catch(err => {
                    reject(err)
                })
            }
            
        })
       
    
    }
   
#### promise.finally
finally 特点：不接收任何参数;finally 本质上是 then 方法的特例 
    
    Promise.prototype.finally = function (callback) {
      let P = this.constructor
      return this.then(
        value  => P.resolve(callback()).then(() => value),
        reason => P.resolve(callback()).then(() => { throw reason })
      )
    }

#### then(a,b)与then(a).catch(b)一样么
在then里发生错误的时候，不会被then的第二个函数捕获。
### 数组
#### 数组的方法
push,pop,shift,unshift,splice,slice,indexof,concat,join,sort,reverse,fiflter,map,foreach,find
#### 数组的哪些方法能够改变原数组
pop,push,shift,unshift,sort,reverse,splice
#### 实现一个数组的深拷贝和浅拷贝
        
        
            // 浅拷贝
            let shallowClone = function (obj) {
                // 不是对象的话，return
                if(typeof obj != 'object' || !obj){
                    return obj
                }
            
                // 根据类型判断应该新建一个数组还是对象
                let newObj = obj instanceof Array ? [] : {}
                // 遍历obj，只有obj的属性才拷贝
                for(let key in obj){
                    if(obj.hasOwnProperty(key)){
                        newObj[key] = obj[key]
                    }
                }
                return newObj
            }
            // 深拷贝
            let deepClone = function (obj) {
                // 不是对象的话，return
                if(typeof obj != 'object' || !obj){
                    return obj
                }
            
                // 根据类型判断应该新建一个数组还是对象
                let newObj = obj instanceof Array ? [] : {}
                // 遍历obj，obj所有的属性都拷贝
                for(let key in obj){
                    if(obj.hasOwnProperty(key)){
                        newObj[key] = deepClone(obj[key])
                    }
                }
                return newObj
            }
#### 查找数组中最大的一个数
1.Math.max(...arr)
2.for
3.sort/sort+reserve
#### 数组去重
- indexOf


    let newArr = []
    arr.forEach(function(item){
         if(newArr.indexOf(item) == -1){
            newArr.push(item)
         }
    })
    // 不能过滤掉 NaN、Object

- for


    let newArr=[];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i+1; j < arr.length; j++) {
            if(arr[i]===arr[j]){
                ++i;
            }
        }
        newArr.push(arr[i]);
    }
    // 不能过滤掉 NaN、Object

- filter


    let newArr = arr.filter((x, index, self)=>{
      // x : 数组每一项的值
      // index: 每一项的下标
      // self: 当前数组
      return self.indexOf(x)===index
    })
    // 不能过滤掉 NaN、Object

- map


    let newArr = []
    let map = new Map()
    for(let i = 0; i < arr.length; i++) {
        if(!map.has(arr[i])) {
            map.set(arr[i])
            newArr.push(arr[i])
        }
    }
    console.log(newArr)
    // 无法过滤对象

- set

    
    new Set(arr)
    // 无法过滤对象

- includes


    let newArr = []
    arr.forEach(function(item){
        if(!newArr.includes(item)){
            newArr.push(item)
        }
    })
    console.log(newArr)
    // 无法过滤对象

- 利用对象的key
    
    
    let obj = {}
    let newArr = []
    for(let i = 0; i < arr.length; i++) {
        if(!obj[arr[i]]){
            obj[arr[i]] = 1
            newArr.push(arr[i])
        }
    }
    console.log(newArr)
    // nan，object都能过滤掉，但是会把‘nan’和nan视为同一个
### == === Object.is
==因为是值比较，故而在一些情况下会自动做类型转换再比较。也就是常说的js隐式转换。
===比较时，就是类型和值的比较了
ps:=== 运算符（和== 运算符）将数字值 -0 和 +0 视为相等，并认为 Number.NaN 不等于 NaN。
Object.is
    两个值都是 undefined
    两个值都是 null
    两个值都是 true 或者都是 false
    两个值是由相同个数的字符按照相同的顺序组成的字符串
    两个值指向同一个对象
    两个值都是数字并且
    都是正零 +0
    都是负零 -0
    都是 NaN
    都是除零和 NaN 外的其它同一个数字

### 事件委托
    
    function delegate(element, eventType, selector, fn) {
         element.addEventListener(eventType, e => {
           let el = e.target
           while (!el.matches(selector)) {
             if (element === el) {
               el = null
               break
             }
             el = el.parentNode
           }
           el && fn.call(el, e, el)
         })
         return element
       }

    
### this
1.判断this的绑定：new,call/apply/bind,对象调用，默认绑定
2.使用new调用函数发生构造函数调用时，执行以下操作
创建一个全新的对象--->这个新对象会被执行prototype链接--->这个新对象会绑定到函数调用的this--->如果函数中没有返回其他的对象，那么new表达式中的函数调用会自动返回这个新对象
3.apply,call,bind的区别

    // call
    // 传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 thisArgs.func(...args)
 
    Function.prototype.call = function(thisArg, args) {
        // this指向调用call的对象
        if (typeof this !== 'function') { // 调用call的若不是函数则报错
            throw new TypeError('Error')
        }
        thisArg = thisArg || window
        thisArg.fn = this   // 将调用call函数的对象添加到thisArg的属性中
        const result = thisArg.fn(...[...arguments].slice(1)) // 执行该属性
        delete thisArg.fn   // 删除该属性
        return result
    }
    
    // bind
    Function.prototype.bind2 = function (context) {
        if (typeof this !== "function") {
          throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
        }
        var self = this;
        var args = Array.prototype.slice.call(arguments, 1);
        
        var fBound = function () {
            var bindArgs = Array.prototype.slice.call(arguments);
            return self.apply(
                this instanceof fNOP ? this : context, 
                args.concat(bindArgs)
            );
        }
        fBound.prototype = Object.create(this.prototype);
        return fBound;
    }
        
### 闭包
定义：定义在函数内部的函数，函数内部持有外部变量的引用
用途：读取函数内部的变量；让变量一直存储，不会被回收；方便调用上下文的局部变量，利于封装，函数式编程，compose curry；模块模式，可以定义私有的变量函数，同时也可以提供给外部api；
### 继承
- 原型链继承


    function Father() {
        this.color = ['color1','color2']
    }
    Father.prototype.getColor = function () {
        return this.color
    }
    function Son() {
    
    }
    
    Son.prototype = new Father()
    
    let instance = new Son()
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    
    let instance2 = new Son()
    console.log(instance2.color) // ['color1','color2','color3']
    
    let instance3 = new Father()
    
    console.log(instance3.color) // ['color1','color2']
    
问题:如果是包含引用类型的原型属性会被所有实例共享；创建子类型的实例，不能向父类型的构造函数中传参

- 借用构造函数继承


    function Father() {
        this.color = ['color1','color2']
    }
    function Son() {
        Father.call(this) // 在子类型中调用父类型的构造函数，每一个实例创建的时候都会走到这里，相当与每个实例都有一个color的副本
    }
    
    let instance = new Son()
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    
    let instance2 = new Son()
    console.log(instance2.color) // ['color1','color2']
    
    let instance3 = new Father()
    console.log(instance3.color) // ['color1','color2']
    
问题:没啥复用性了，所有的东西都放构造函数里了

- 组合继承


    function Father(name) {
        this.name = name
        this.color = ['color1','color2']
    }
    Father.prototype.sayName = function () {
        console.log(this.name)
    }
    function Son(name,age) {
        Father.call(this,name)
        this.age = age
    }
    Son.prototype = new Father()
    Son.prototype.sayAge = function () {
        console.log(this.age)
    }
    
    let instance = new Son('wangyuqing','23')
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    instance.sayName()
    instance.sayAge()
    
    let instance2 = new Son('chenjun',25)
    console.log(instance2.color) // ['color1','color2','color3']
    instance2.sayName()
    instance2.sayAge()
    
解决了原型链和借用构造函数的缺点

- 原型式继承


    let person = {
       name:'person',
       family:['mother','me']
    }
    let person1 = Object.create(person)
    person1.name = 'person1'
    person1.family.push('father')
    console.log(person1.name)
    console.log(person1.family)
    
    let person2 = Object.create(person)
    person2.name = 'person2'
    console.log(person2.name)
    console.log(person2.family)
    
    console.log(person.name)

问题：和原型链继承一样，实例会对引用类型的属性进行共享

- 寄生式继承


    function creatAnthor(data){
        let clone = Object.create(data)
        clone.sayHi = function () {
            console.log('hi')
        }
        return clone
    }
    let person = {
        name:'person',
        family:['mother','me']
    }
    let person1 = creatAnthor(person)
    person1.sayHi()
    person1.name = 'person1'
    person1.family.push('father')
    console.log(person1.name)
    console.log(person1.family)
    
    let person2 = creatAnthor(person)
    person2.name = 'person2'
    person2.sayHi()
    console.log(person2.name)
    console.log(person2.family)
    
问题：和原型式继承基本一样，只是封装了一个方法返回了一个新对象，这个对象不仅有原来的data的属性和方法，还有自己的方法。其实就是在原型式继承上增强一下。与构造函数模式类似，会有做不到复用的情况。

- 重中之重：寄生组合式继承

    
    function Father(name) {
        this.name = name
        this.color = ['color1','color2']
    }
    Father.prototype.sayName = function () {
        console.log(this.name)
    }
    function Son(name,age) {
        Father.call(this,name)
        this.age = age
    }
    
    // Son.prototype = new Father()  组合继承的实现，会执行两次父类构造函数
    // -----新增-----
    // 其实就是把父类的原型指给子类的原型，但因为怕只想原型的过程中constructor丢失，就手动指一下
    let prototype = Object.create(Father.prototype) // 创建对象
    prototype.constructor = Son // 增强对象
    Son.prototype = prototype // 指定对象
    
    Son.prototype.sayAge = function () {
        console.log(this.age)
    }
    
    let instance = new Son('wangyuqing','23')
    instance.color.push('color3')
    console.log(instance.color) // ['color1','color2','color3']
    instance.sayName()
    instance.sayAge()
    
    let instance2 = new Son('chenjun',25)
    console.log(instance2.color) // ['color1','color2','color3']
    instance2.sayName()
    instance2.sayAge()

解决了执行两次父类构造函数的问题
### 原型
    function Foo() {...};
    let f1 = new Foo();

以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示：
![1](/image/原型链/1.png)
①__proto__和constructor属性是对象所独有的；
② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。
__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。
constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。
### 模块
- commonjs
一个文件就是一个模块，拥有独立作用域，深拷贝。
运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
- es6
模块内部函数改变了模块内的对象，外部导出使用的对象也跟着发生了变化
编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。
- AMD规范
崇依赖前置，在定义模块的时候就要声明其依赖的模块,JS可以方便知道依赖模块是谁，立即加载
所有的模块都进行异步加载，模块加载不影响后面语句运行。
所有依赖某些模块的语句均放置在回调函数中。
提供全局define 函数（方法）来定义模块，require引入模块，exports导出模块。
- CMD规范
推崇就近依赖，只有在用到某个模块的时候再去require,需要使用把模块变为字符串解析一遍才知道依赖了那些模块。
### commonjs和es6模块的区别
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
CommonJs 是单个值导出，ES6 Module可以导出多个
CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined

### ajax

    let ajax = {
        get:function (url,fn,async) {
            let xhr=new XMLHttpRequest();
            xhr.open('GET',url,async);
            xhr.onreadystatechange = function () {
                if(xhr.readyState === 4){
                    if(xhr.status === 200 || xhr.status === 304){
                        fn.call(xhr.responseText);
                    }
                }
            }
            xhr.send();
        },
        post:function (url,data,fn,async) {
            let xhr = new XMLHttpRequest();
            xhr.open('POST',url,async);
            xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded')
            xhr.onreadystatechange = function () {
                if(xhr.readyState === 4){
                    if(xhr.status === 200 || xhr.status === 304){
                        fn.call(xhr.responseText);
                    }
                }
            }
            xhr.send(data);
        }
    }
    
readyState   
0：请求未初始化，还没有调用 open()。
1：请求已经建立，但是还没有发送，还没有调用 send()。
2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。
3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。
4：响应已完成；您可以获取并使用服务器的响应了。
       
       
## VUE
### vue里为什么只有一个跟元素
$mount传了一个el参数，这个参数可以是string类型，也可以是一个element元素，也就是dom节点,然后仅仅返回匹配指定选择器的第一个元素
Vue其实并不知道哪一个才是我们的入口，因为对于一个入口来讲，这个入口就是一个Vue类，Vue需要把这个入口里面的所有东西拿来渲染、处理，最后再重新插入到dom中。如果同时设置了多个入口，那么vue就不知道哪一个才是这个类。

### vue响应式原理
![1](/image/前端面试题集/1.jpg) 
Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新
Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。
Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种。watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。
compile : 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，

    Object.defineProperty(obj, "key", {
      enumerable: false,    // 为 true 时，可枚举
      configurable: false, // 为 true 时，该属性描述符才能够被改变
      writable: false, // 为 true 时，value才能被赋值运算符改变
      value: "static" // 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）
    });
    
### computed原理(computed-watcher)
computed 本质是一个惰性求值的观察者。
computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。
其内部通过 this.dirty 属性标记计算属性是否需要重新求值。
computed中初始化对各个属性生成的watcher的dirty和lazy都设置为了true
当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,
computed watcher 通过 this.dep.subs.length 判断有没有订阅者,
有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)
在一次依赖收集期间，如果有其他依赖收集任务开始（比如：当前 computed 计算属性嵌套其他 computed 计算属性），那么将会把当前 target 暂存到 targetStack，先进行其他 target 的依赖收集，当嵌套的依赖收集任务完成后，将 target 恢复为上一层的 Watcher，并继续做依赖收集

    var vm = new Vue({
      el: '#example',
      data: {
        message: 'Hello'
      },
      computed: {
        // 计算属性的 getter
        reversedMessage: function () {
          // `this` 指向 vm 实例
          return this.message.split('').reverse().join()
        }
      }
    })
    vm.reversedMessage // =>  olleH
    vm.message = 'World' // 
    vm.reversedMessage // =>  dlroW
    
    1.初始化 data和computed,分别代理其set以及get方法, 对data中的所有属性生成唯一的dep实例。
    2.对computed中的reversedMessage生成唯一watcher,并保存在vm._computedWatchers中
    3.访问 reversedMessage，设置Dep.target指向reversedMessage的watcher,调用该属性具体方法reversedMessage。
    4.方法中访问this.message，即会调用this.message代理的get方法，将this.message的dep加入reversedMessage的watcher,同时该dep中的subs添加这个watcher
    5.设置vm.message = 'World'，调用message代理的set方法触发dep的notify方法'
    6.因为是computed属性，只是将watcher中的dirty设置为true
    7.最后一步vm.reversedMessage，访问其get方法时，得知reversedMessage的watcher.dirty为true,调用watcher.evaluate()方法获取新的值。
    
### watcher原理（user-watcher）
其实就是对watch的一种封装，不是数组直接使用watcher，是数组的话遍历所有数组，将每一项使用watcher包装。
参数immediate就以当前值立即执行一次回调函数
参数deep如果为true，其实就是增加一步，在Dep.target = null 前，递归的对它的子值进行依赖收集。
考虑到watch可能也会对一个函数进行监听，watcher会同时对这个函数里面依赖的响应式数据进行监听，this.getter = expOrFun
### complier原理
Vue complier 是将 template 转化成一个 render 字符串
解析器将模版解析成AST，parse过程中会触发钩子函数，比如标签开始，标签结束，解析文本，解析注释。构建AST层级就是通过一个栈来维护，这个栈也可以叫做DOM的深度
优化器遍历AST标记静态节点,diff过程跳过静态节点，提升性能。通过递归的方式从上到下标记静态节点，静态节点的特征是他的子节点必须是静态节点。标记完静态节点就开始标记静态跟节点，从上到下寻找碰到的第一个静态节点就是静态根节点。有两种情况特殊：如果一个静态根节点的子节点只有一个文本节点；如果静态跟节点没有子节点。不会把它标记成静态跟节点。优化成本大于收益
代码生成器将AST生成代码字符串。`_c(div,{attrs:{id:1}}, [_c('div')])` 还有_v _e
### vm.$set()实现原理
1.如果是数组的话，通过splice自动来触发响应
2.如果目标元素已经存在，说明已经是响应式数据了，直接改变值就行了
3.处理新增属性，如果target上有_ob_证明他是被监测的，直接调用definedReactive();ob.dep.notify()就行了;如果没有ob,直接更改值就行了

    export function set(target: Array<any> | Object, key: any, val: any): any {
        // target 为数组  
        if (Array.isArray(target) && isValidArrayIndex(key)) {
            // 修改数组的长度, 避免索引>数组长度导致splice()执行有误
            target.length = Math.max(target.length, key);
            // 利用数组的splice变异方法触发响应式
            target.splice(key, 1, val);
            return val;
        }
        // target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值
        if (key in target && !(key in Object.prototype)) {
            target[key] = val;
            return val;
        }
        // 以上都不成立, 即开始给target创建一个全新的属性  // 获取Observer实例 
        const ob = (target: any).__ob__;
        // target 本身就不是响应式数据, 直接赋值 
        if (!ob) {
            target[key] = val;
            return val;
        }
        // 进行响应式处理 
        defineReactive(ob.value, key, val);
        ob.dep.notify();
        return val;
    }
       
### $on,$off,$emit,$once原理
    
    class Vue {
        constructor() {
            this._events = Object.create(null);
        }
    
        // 注册事件时，将回调函数收集起来，在触发函数时将收集起来的回调挨个触发一遍
        $on(event, fn) {
            if (Array.isArray(event)) {
                event.map(item => {
                    this.$on(item, fn);
                });
            } else {
                (this._events[event] || (this._events[event] = [])).push(fn);
            }
            return this;
        }
        // 只执行一次，所以思路就是通过$on监听，监听完了就用off把他删掉，手动触发一下回调即可。
        $once(event, fn) {
            function on() {
                this.$off(event, on);
                fn.apply(this, arguments);
            }
    
            on.fn = fn;
            this.$on(event, on);
            return this;
        }
        // 移除监听器
        $off(event, fn) {
            // 移除所有的监听器
            if (!arguments.length) {
                this._events = Object.create(null);
                return this;
            }
            // 数组的情况下，每一项都移除一遍
            if (Array.isArray(event)) {
                event.map(item => {
                    this.$off(item, fn);
                });
                return this;
            }
            // 只提供事件，没提供具体的回调，那就把这个事件的所有监听删除
            const cbs = this._events[event];
            if (!cbs) {
                return this;
            }
            if (!fn) {
                this._events[event] = null;
                return this;
            }
            // 最后一种情况，参数都齐了，循环监听器数组，找到一样的，删掉
            let cb;
            let i = cbs.length;
                // 从后向前遍历。因为是删除元素，如果从前往后遍历，会遇到条过一个元素的情况
            while (i--) {
                cb = cbs[i];
                if (cb === fn || cb.fn === fn) {
                    cbs.splice(i, 1);
                    break;
                }
            }
            return this;
        }
        // 拿到事件监听的数组，循环数组，将参数传入回调函数中，依次触发。
        $emit(event) {
            let cbs = this._events[event];
            if (cbs) {
                const args = [].slice.call(arguments, 1);
                cbs.map(item => {
                    args ? item.apply(this, args) : item.call(this);
                });
            }
            return this;
        }
    }
### v-model实现的原理
语法糖：
    
    <Hello v-model="name"/> 解析为
    <Hello :value="name" @change="data => name = data"/>
    
    <input v-model="name"/> 解析为
    <input :value="name" @input="name = $event.target.value">

### vue生命周期
![2](/image/前端面试题集/2.jpg) 

### keep-alive原理
获取 keep-alive 包裹着的第一个子组件对象及其组件名
根据设定的 include/exclude（如果有）进行条件匹配,决定是否缓存。不匹配,直接返回组件实例
根据组件 ID 和 tag 生成缓存 Key,并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关键)
在 this.cache 对象中存储该组件实例并保存 key 值,之后检查缓存的实例数量是否超过 max 的设置值,超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为 0 的那个 key）
最后组件实例的 keepAlive 属性设置为 true,这个在渲染和执行被包裹组件的钩子函数会用到,这里不细说

当keep-alive组件激活时，触发activated，keep-alive组件停用时调用deactivated

### new Vue()实例中,data 可以直接是一个对象,为什么在 vue 组件中,data 必须是一个函数呢?
因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。
所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。
### vue如何对数组进行重写监听的
简单来说,Vue 通过原型拦截的方式重写了数组的 7 个方法，首先获取到这个数组的ob,也就是它的 Observer 对象,如果有新的值,就调用 observeArray 对新的值进行监听,然后手动调用 notify,通知 render watcher,执行 update

    const arrayProto = Array.prototype;
    export const arrayMethods = Object.create(arrayProto);
    const methodsToPatch = [  "push",  "pop",  "shift",  "unshift",  "splice",  "sort",  "reverse"];
    /** * Intercept mutating methods and emit events */
    methodsToPatch.forEach(function(method) {  
    // cache original method  
    const original = arrayProto[method];  
        def(arrayMethods, method, function mutator(...args) {    
            const result = original.apply(this, args);    
            const ob = this.__ob__;    
            let inserted;    
            switch (method) {      
                case "push":      
                case "unshift":        
                    inserted = args;        
                    break;      
                case "splice":        
                    inserted = args.slice(2);        
                    break;    
            }    
            if (inserted) ob.observeArray(inserted);    
            // notify change    
            ob.dep.notify();    
            return result;  
        });
    });
    /** * Observe a list of Array items. */
    Observer.prototype.observeArray = function observeArray(items) {  
        for (var i = 0, l = items.length; i < l; i++) {   
            observe(items[i]);  
        }
    };
    
    
### watch和computed的区别
computed是计算属性，类似与过滤器，对绑定在view上的数据进行处理，computed的属性不能在data里赋值,具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数
watch是一个观察动作，可以通过deep:true来进行深度监听。打印oldVal和newVal值一样的原因是它们索引同一个对象/数组，Vue 不会保留修改之前值的副本，深度监听的函数必须是handler，因为watcher里面对应的是对handler的调用.无缓存性，页面重新渲染时值不变化也会执行
    
     watch:{
          secondChange:{
            handler(oldVal,newVal){
              console.log(oldVal)
              console.log(newVal)
            },
            deep:true
          }
        },

监听对象单个属性

    // 方法一：可以直接对用对象.属性的方法拿到属性
    data(){
      return{
        'first':{
          second:0
        }
      }
    },
    watch:{
      first.second:function(newVal,oldVal){
        console.log(newVal,oldVal);
      }
    }
    
    // 方法二：watch如果想要监听对象的单个属性的变化,必须用computed作为中间件转化,因为computed可以取到对应的属性值
    data(){
      return{
        'first':{
          second:0
        }
      }
    },
    computed:{
      secondChange(){
        return this.first.second
      }
    },
    watch:{
      secondChange(){
        console.log('second属性值变化了')
      }
    },
               
### diff 算法
diff 的实现主要通过两个方法，patchVnode 与 updateChildren。

patchVnode 有两个参数，分别是老节点 oldVnode, 新节点 vnode。主要分五种情况：
if (oldVnode === vnode)，他们的引用一致，可以认为没有变化。
if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text)，文本节点的比较，需要修改，则会调用Node.textContent = vnode.text。
if( oldCh && ch && oldCh !== ch ), 两个节点都有子节点，而且它们不一样，这样我们会调用 updateChildren 函数比较子节点，这是diff的核心，后边会讲到。
if (ch)，只有新的节点有子节点，调用createEle(vnode)，vnode.el已经引用了老的dom节点，createEle函数会在老dom节点上添加子节点。
if (oldCh)，新节点没有子节点，老节点有子节点，直接删除老节点。

updateChildren
oldCh 和 newCh 各有两个头尾的变量 StartIdx 和 EndIdx ，它们的2个变量相互比较，一共有4种比较方式。如果 4 种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。
### 过滤器


    <!-- 在双花括号中 -->
    {{ message | capitalize }}
    
    <!-- 在 `v-bind` 中 -->
    <div v-bind:id="rawId | formatId"></div>
    
    filters: {
      capitalize: function (value) {
        if (!value) return ''
        value = value.toString()
        return value.charAt(0).toUpperCase() + value.slice(1)
      }
    }
    
    
### 父子组件的通讯
父子组件通信: props; $parent / $children; provide / inject ; ref ; $attrs / $listeners
兄弟组件通信: eventBus ; vuex
跨级通信: eventBus；Vuex；provide / inject 、$attrs / $listeners
### localstorage怎么监听
同源的不同页面，监听事件就行了

    window.addEventListener("storage", function (e) {
            console.log(e.newValue);
    });
同页面，对 localStorage 的 setItem 方法进行重写
    
    var orignalSetItem = localStorage.setItem;
    localStorage.setItem = function(key,newValue){
          var setItemEvent = new Event("setItemEvent");
          setItemEvent.key = key;
          setItemEvent.newValue = newValue;
          window.dispatchEvent(setItemEvent);
          orignalSetItem.apply(this,arguments);
    }
    window.addEventListener("setItemEvent", function (e) {
        console.log(e.newValue);
    });
    localStorage.setItem("name","wang");

在vue中

    /**
     * @param { number } type 1 localStorage 2 sessionStorage
     * @param { string } key 键
     * @param { string } data 要存储的数据
     * @returns 
     */
    // 如果报prototype无法被识别的错误，可以把原型方法挂在到__proto__
    Vue.prototype.$addStorageEvent = function (type, key, data) {
        if (type === 1) {
            // 创建一个StorageEvent事件
            var newStorageEvent = document.createEvent('StorageEvent');
            const storage = {
                setItem: function (k, val) {
                    localStorage.setItem(k, val);
                    // 初始化创建的事件
                    newStorageEvent.initStorageEvent('setItem', false, false, k, null, val, null, null);
                    // 派发对象
                    window.dispatchEvent(newStorageEvent);
                }
            }
            return storage.setItem(key, data);
        } else {
            // 创建一个StorageEvent事件
            var newStorageEvent = document.createEvent('StorageEvent');
            const storage = {
                setItem: function (k, val) {
                    sessionStorage.setItem(k, val);
                    // 初始化创建的事件
                    newStorageEvent.initStorageEvent('setItem', false, false, k, null, val, null, null);
                    // 派发对象
                    window.dispatchEvent(newStorageEvent);
                }
            }
            return storage.setItem(key, data);
        }
    }
    二、组件中调用：
    
    this.$addStorageEvent(2, "user_info", data);
    三、在另一个组件中的 mounted 钩子函数中监听：
    
    window.addEventListener('setItem', (e) => {
      //获取参数
         console.log(e);
    });
    
### 组件的类别
全局组件和局部组件
全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。

### vue-router原理

作为参数传入的字符串属性mode只是一个标记，用来指示实际起作用的对象属性history的实现类，两者对应关系如下：
'history':HTML5History
'hash':HashHistory
'abstract':AbstractHistory
在初始化对应的history之前，会对mode做一些校验：若浏览器不支持HTML5History方式（通过supportsPushState变量判断），则mode强制设为'hash'；若不是在浏览器环境下运行，则mode强制设为'abstract'
VueRouter类中的onReady(), push()等方法只是一个代理，实际是调用的具体history对象的对应方法，在init()方法中初始化时，也是根据history对象具体的类别执行不同操作

- HashHistory
hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面
可以为hash的改变添加监听事件： window.addEventListener("hashchange", funcRef, false)
每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录

在全局install了router的插件，beforeCreate钩子中定义了响应式的_route属性，当通过$router.push() --> HashHistory.push() 进行路由更改的时候，route值改变了，就触发render

- HTML5History
History interface是浏览器历史记录栈提供的接口，通过back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改：
    
    
    window.history.pushState(stateObject, title, URL)
    window.history.replaceState(stateObject, title, URL)
    
两种模式比较

pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL
pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中
pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串
pushState可额外设置title属性供后续使用    

### vue-router实现路由懒加载

1.import按需加载（官方写法）

    const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')

2.vue异步组件

    {
        path: '/path',
        name: 'componentName',
        component: resolve => require(['@/componentPath'], resolve),
    }
      
### 动态加载路由

    const router = new Router({
      routes: [
        {path: '/', redirect: '/home'},
      ]  
    })
     
    router.addRoutes([
      {
        path: '/login',
        name: 'login',
        component: () => import('../components/Login.vue')
      }
    ])
### 路由守卫
全局前置守卫 beforeEach(to,from,next)
全局后置守卫 afterEach(to,from)
路由守卫 beforeEnter(to, from, next)
组件内守卫 beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave

### 完整的路由导航解析流程
1.导航被触发。
2.在失活的组件里调用 beforeRouteLeave 守卫。
3.调用全局的 beforeEach 守卫。
4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5.在路由配置里调用 beforeEnter。
6.解析异步路由组件。
7.在被激活的组件里调用 beforeRouteEnter。
8.调用全局的 beforeResolve 守卫 (2.5+)。
9.导航被确认。
10.调用全局的 afterEach 钩子。
11.触发 DOM 更新。
12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
### vue的频繁变化为什么只变化一次
### 自定义指令
### vue data为什么是个函数不是个对象
如果两个实例引用同一个对象，当其中一个实例的属性发生改变时，另一个实例属性也随之改变，只有当两个实例拥有自己的作用域时，才不会相互干扰。
### VUE和react怎样选择
1.数据是不是可变的
react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。react在setState之后会重新走渲染的流程，如果shouldComponentUpdate返回的是true，就继续渲染，如果返回了false，就不会重新渲染，PureComponent就是重写了shouldComponentUpdate，然后在里面作了props和state的浅层对比。
而vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。
总之，react的性能优化需要手动去做，而vue的性能优化是自动的，但是vue的响应式机制也有问题，就是当state特别多的时候，Watcher也会很多，会导致卡顿，所以大型应用（状态特别多的）一般用react，更加可控。
2.通过js来操作一切，还是用各自的处理方式
vue有模版写法，更趋向于常规的开发模式，react的写法是全部基于js，适配现有项目难度较高
3.什么功能内置，什么交给社区去做
vue内置了很多功能，而react做的很少，很多都是由社区来完成的，vue追求的是开发的简单，而react更在乎方式是否正确。

1.Vue 进行数据拦截/代理，它对侦测数据的变化更敏感、更精确，也间接对一些后续实现（比如 hooks，function based API）提供了很大的便利。这个我们后面会提到；React 推崇函数式，它直接进行局部重新刷新（或者重新渲染），这样更粗暴，但是更简单，让我们的开发回到了上古时代，就是刷新呗，前端开发非常简单。但是 React 并不知道什么时候“应该去刷新”，触发局部重新变化是由开发者手动调用 setState 完成。React setState 引起局部重新刷新。为了达到更好的性能，React 暴漏给开发者 shouldComponentUpdate 这个生命周期 hook，来避免不需要的重新渲染（相比之下，Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少，而 React 对数据变化毫无感知，它就提供 React.createElement 调用已生成 virtual dom）。另外 React 为了弥补不必要的更新，会对 setState 的行为进行合并操作。因此 setState 有时候会是异步更新，但并不是总是“异步”。这个设计上的差别，直接影响了 hooks 的实现和表现。React hook 底层是基于链表（Array）实现，每次组件被 render 的时候都会顺序执行所有的 hooks，因为底层是链表，每一个 hook 的 next 是指向下一个 hook 的，所以要求开发者不能在不同 hooks 调用中使用判断条件，因为 if 会导致顺序不正确，从而导致报错。相反，vue hook 只会被注册调用一次，vue 之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于响应式的，是对数据进行了代理的。他不需要链表进行 hooks 记录，它对数据直接代理观察。但是 Vue 这种响应式的方案，也有自己的困扰。比如 useState() （实际上 evan 命名为 value()）返回的是一个 value wrapper （包装对象）。一个包装对象只有一个属性：.value ，该属性指向内部被包装的值。我们知道在 JavaScript 中，原始值类型如 string 和 number 是只有值，没有引用的。不管是使用 Object.defineProperty 还是 Proxy，我们无法追踪原始变量后续的变化。因此 Vue 不得不返回一个包装对象，不然对于基本类型，它无法做到数据的代理和拦截。这算是因为设计理念带来的一个非常非常微小的  side effect。

### 如何批量引入组件

    
    // 引入所有需要的动态组件
    const requireComponent = require.context(
      "./", //组件所在目录的相对路径
      true, //是否查询其子目录
      /\w+\.vue$/ //匹配基础组件文件名的正则表达式
    );
    var comObj = {};
    requireComponent.keys().forEach(fileName => {
      // 获取文件名
      var names = fileName.split("/").pop().replace(/\.\w+$/, "");
      // 获取组件配置
      const componentConfig = requireComponent(fileName);
      // 若该组件是通过"export default"导出的，优先使用".default"，否则退回到使用模块的根
      comObj[names] = componentConfig.default || componentConfig;
    });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

## VUEX
### vuex流程
![1](https://vuex.vuejs.org/vuex.png) 
在vue组件里面，通过dispatch来触发actions提交修改数据的操作。
然后再通过actions的commit来触发mutations来修改数据。
mutations接收到commit的请求，就会自动通过Mutate来修改state（数据中心里面的数据状态）里面的数据。
最后由store触发每一个调用它的组件的更新

### 核心概念
- state是存储的单一状态，是存储的基本数据。
- Getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。
- Mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）
- Actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）
- Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。

### vuex原理
![2](http://img1.sycdn.imooc.com/5d5813ab0001a8b910021104.png) 
    
    
    // src/store.js
    function resetStoreVM (store, state, hot) {
      // 省略无关代码
      Vue.config.silent = true
      store._vm = new Vue({
        data: {
          $$state: state
        },
        computed
      })
    }
    
beforeCreate生命周期注入了设置this.$store这样一个对象
其本质就是将我们传入的state作为一个隐藏的vue组件的data,也就是说，我们的commit操作，本质上其实是修改这个组件的data值，结合上文的computed,修改被defineReactive代理的对象值后，会将其收集到的依赖的watcher中的dirty设置为true,等到下一次访问该watcher中的值后重新获取最新值。
这样就能解释了为什么vuex中的state的对象属性必须提前定义好，如果该state中途增加一个属性，因为该属性没有被defineReactive，所以其依赖系统没有检测到，自然不能更新
2.computed和vuex里的getter有什么区别
3.vuex里的getter和mutation有什么区别

## REACT

- react的生命周期
- setState有时候是同步的？异步？批量更新
- React diff
- react 事件处理
### react 组件
函数/无状态/展示组件：函数或无状态组件是一个纯函数，它可接受接受参数，并返回react元素。这些都是没有任何副作用的纯函数。这些组件没有状态或生命周期方法
类/有状态组件：类或有状态组件具有状态和生命周期方可能通过setState()方法更改组件的状态。类组件是通过扩展React创建的。它在构造函数中初始化，也可能有子组件
受控组件：受控组件是在 React 中处理输入表单的一种技术。表单元素通常维护它们自己的状态，而react则在组件的状态属性中维护状态。我们可以将两者结合起来控制输入表单。这称为受控组件。因此，在受控组件表单中，数据由React组件处理。
非受控组件：大多数情况下，建议使用受控组件。有一种称为非受控组件的方法可以通过使用Ref来处理表单数据。在非受控组件中，Ref用于直接从DOM访问表单值，而不是事件处理程序。也就是说，只能让用户控制，而不是程序控制
容器组件：容器组件是处理获取数据、订阅 redux 存储等的组件。它们包含展示组件和其他容器组件，但是里面从来没有html。比如一个列表，每一项都是一个组件，但整个列表可以做为一个容器组件
>mixin:就是用赋值的方式将mixin对象里的方法都挂载到原型上，来实现对对象的混入。缺点：由于Mixin过多会使得组件难以维护，在React ES6中Mixin不再被支持。
    
    const mixin = function (obj,mixin) {
     const newObj = obj;
     newObj.prototype = Object.create(obj.prototype)
     for(let prop in mixin){
      if(mixin.hasOwnProperty(prop)){
       newObj.prototype[prop] = mixin[prop]
      }
     }
     return newObj
    }
    

高阶组件：高阶组件是一个接替Mixin实现抽象组件公共功能的好方法。高阶组件其实是一个函数，接收一个组件作为参数，返回一个包装组件作为返回值，类似于高阶函数。高阶组件和装饰器就是一个模式，因此，高阶组件可以作为装饰器来使用。
优点：适用范围广，它不需要es6或者其它需要编译的特性，有函数的地方，就有HOC。Debug友好，它能够被React组件树显示，所以可以很清楚地知道有多少层，每层做了什么。
用法：
属性代理(Props Proxy): 高阶组件通过ComponentClass的props来进行相关操作。
1. 操作props
2. 通过refs访问组件实例
3. 提取state
4. 用其他元素包裹WrappedComponent，实现布局等目的
继承反转(Inheritance Inversion)): 高阶组件继承自ComponentClass
HOC继承了WrappedComponent，意味着可以访问到WrappedComponent的state，props，生命周期和render方法。如果在HOC中定义了与WrappedComponent同名方法，将会发生覆盖，就必须手动通过super进行调用。通过完全操作WrappedComponent的render方法返回的元素树，可以真正实现渲染劫持。这种思想具有较强的入侵性。

创建组件：React.Component/function
### Hook
Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。
useState通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。
useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。

## REDUX

### redux原理
### redux流程
将需要修改的state都存入到store里，发起一个action用来描述发生了什么，用reducers描述action如何改变state tree 。创建store的时候需要传入reducer，真正能改变store中数据的是store.dispatch API。
### applyMiddleware
1、applyMiddleware顾名思义，用于调用各种中间件；
2、applyMiddleware执行后，将所有入参中间件存入一个数组，并且返回一个闭包（闭包的概念不做累述）
3、闭包接受一个createStore作为入参并且执行后返回下一个闭包，createStore这个入参有没有很眼熟，没错，就是redux的createStore。
返回将所有中间件串联存入的dispatch，执行时从右向左执行，第一次的执行结果会返回给一下个，依次类推。
### redux中间件
dispatch一个action之后，到达reducer之前，进行一些额外的操作，就需要用到middleware。你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。换言之，中间件都是对store.dispatch()的增强,dispath的时候在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。

    function createThunkMiddleware(extraArgument) {
      return function({ dispatch, getState }) {
        return function(next){
          return function(action){
            if (typeof action === 'function') {
              return action(dispatch, getState, extraArgument);
            }
            return next(action);
          };
        }
      }
    }
redux-thunk最重要的思想，就是可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。因为这个action creator可以返回一个函数，那么就可以在这个函数中执行一些异步的操作
    
## react native

### 热更新



## WEBPACK
### 什么是webpack
webpack是一个打包工具，他的宗旨是一切静态资源皆可打包。规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。
### webpack核心概念
1.Entry（入口）：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
2.Output（出口）：告诉 webpack 在哪里输出它所创建的结果文件，以及如何命名这些文件，默认值为./dist。
3.Loader（模块转换器）：将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。
4.Plugins（插件）：在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。
5.Module(模块)：开发者将程序分解成离散功能块，并称之为模块，在webpack里一个模块对应着一个文件，webpack会从配置的 Entry 开始递归找出所有依赖的模块。
### webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全
webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，每找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑
Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：
初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
确定入口：根据配置中的 entry 找出所有的入口文件；
编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。
### Webpack与Grunt和Gulp的区别
Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。
Grunt和Gulp的工作方式是：基于任务和流（Task、Stream）的，在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。
gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系。webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工
### loader
1.什么是loader
Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力
2.常见的locader
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去
source-map-loader：加载额外的 Source Map 文件，以方便断点调试
image-loader：加载并且压缩图片文件
babel-loader：把 ES6 转换成 ES5
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
eslint-loader：通过 ESLint 检查 JavaScript 代码
3.loader原理
loader的执行顺序和代码书写的顺序是相反的，即：最后一个loader最先执行，第一个loader最后执行
第一个执行的loader会接收源文件做为参数，下一次执行的loader会接收前一个loader执行的返回值做为参数
单一原则: 每个 Loader 只做一件事；
链式调用: Webpack 会按顺序链式调用每个 Loader；
统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；
4.写一个loader
    
    // webpack.config.js
    rules: [
      {
        test: /\.txt$/,
        use: [
          './loaders/myloader2.js','./loaders/myloader1.js'
        ]
      }
    ]
    // loaders/myloader1.js    
    module.exports = function (src) {
        src = src.split('').reverse().join('')
        return src;
    }
    // loaders/myloader2.js   
    module.exports = function(source) {
      // 通过 this.callback 告诉 Webpack 返回的结果
      // 其中的this.callback是Webpack给Loader注入的API，以方便Loader和Webpack之间通信。
      this.callback(null, source, sourceMaps);
      // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，
      // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 
      return;
    };
    
### Plugin
1.常见的Plugin
define-plugin：定义环境变量
HtmlWebpackPlugin:可以生成创建html入口文件,为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题
uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码，删除警告
CleanWebpackPlugin：清除打包的文件
HotModuleReplacementPlugin：热重载（更新的模块重载）
2.plugin的原理
plugin 本质上就是一个类,有一个 apply 方法，接受一个 compiler 的对象, 我们会在 compiler 对象上钩子挂载一些监听函数，当 compiler 对象上这些钩子触发的时候，就会调用这些函数。Webpack启动后，在读取配置的过程中会先执行new BasicPlugin(options)初始化一个BasicPlugin获得其实例。 在初始化compiler对象后，再调用basicPlugin.apply(compiler)给插件实例传入compiler对象。 插件实例在获取到compiler对象后，就可以通过compiler.plugin(事件名称, 回调函数)监听到Webpack广播出来的事件。 并且可以通过compiler对象去操作Webpack。
3.写一个plugin
    
    // BasicPlugin.js
    class BasicPlugin{
      // 在构造函数中获取用户给该插件传入的配置
      constructor(options){
      
      }
    
      // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象
      apply(compiler){
        compiler.plugin('compilation',function(compilation) {
        
        })
      }
    }
    // 导出 Plugin
    module.exports = BasicPlugin;
    
    
    // webpack.config.js
    const BasicPlugin = require('./BasicPlugin.js');
    module.export = {
      plugins:[
        new BasicPlugin(options),
      ]
    }
    
### 用 webpack 实现 long term cache
思路：哪个模块更新了破坏他的缓存，没更新的模块继续利用缓存。 
1.code splitting

    // 1.多entry方式
    entry: {
        a: './code_split_mode/a.js',
        b: './code_split_mode/b.js'
    },
    // 2.公共提取,拆分代码配置项方式
    optimization: {
        splitChunks: {
          cacheGroups: {
            node_vendors: {
              test: /[\\/]node_modules[\\/]/,
              chunks: 'async',
              priority: 1
            }
          }
        }
    },
    // 3.动态加载
    output: {
      path: config.build.assetsRoot,
      filename: utils.assetsPath('js/[name].[chunkhash].js'),
      chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
    },
    // 4.动态加载在vue中
    // 把每个路由所包含的组件，都分割成一个单独的 bundle（通过import()就已经可以实现了）；当路由被访问的时候才加载该路由对应的 bundle（ue 允许将组件定义为一个工厂函数，异步地解析组件的定义。只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。在工厂函数中可以返回 Promise，而 import() 也是返回 Promise 的，这样就把异步组件和 import() 结合起来了。）
    const router = new VueRouter({
      routes: [
        { path: '/login', component: () => import('@/views/login'), },
        { path: '/home', component: () => import('@/views/home'), }
      ]
    })
      
2.生成稳定的 hash 文件名
    
      output: {
        //...
        filename: '[name].[chunkhash:8].js',
        chunkFilename: '[name].[chunkhash:8].chunk.js',
        //...
      },
    }
    
3.提取 webpack 的 runtime 代码（用来解析和加载模块之类的运行时代码）
    
    new webpack.optimize.CommonsChunkPlugin({ 
      name: ['manifast'] 
    }),
    
4.保持moudule的id
webpack 里每个模块都有一个 module id ，module id 是该模块在模块依赖关系图里按顺序分配的序号，如果这个 module id 发生了变化，那么他的 chunkhash 也会发生变化。
    
    plugins: [
      new webpack.HashedModuleIdsPlugin(),
      // ...
    ],
### 使用webpack优化体积
1.mini-css-extract-plugin提取css
2.new OptimizeCSSAssetsPlugin()压缩css
3.cdn
4.splitChunks
>提取webpack的runtime代码到单独manifest的文件
 所有静态依赖第三方库被分割到同一个文件中,通过cacheGroup
 多入口情况下：被多次引用的自研发模块统一放到一个文件中，便于多个入口共享，整一个common
 配置缓存，new webpack.HashedModuleIdsPlugin()
 多入口情况下：在new HtmlWebpackPlugin下的chunks写如对应页面的引用模块名字
 
5.路由按需加载（webpackchunkname）

### 提升构建速度
1.缩小文件的查找范围
缩小loader的查找范围
当安装的第三方模块肯定在nodemoudles里，就通过resolve.moudules指定nodemoudles
尽量减少resolve.extension的查找后缀，平时引入文件的时候就把后缀都写上
使用module.noparse对一些jquery啥的不进行递归解析处理
2.使用dllplugin
包含大量的复用模块的动态链接库只需要被编译一次，在之后的构建过程中被动态链接库中大多数包含的是常用的第三方模块，例如react，react-dom这种只要不升级，就不重新编译
3.使用happypack
运行在node上的webpack是单线程的，也就是说webpack会一个一个处理任务，不能同时处理多个任务，js也是单线程模型，所以就只能通过多进程而不是多线程
针对loader进行不同的happypack编译
在整个webpack的构建过程中，loader可能是最耗时的，每通过一个new happypack实例化一个happypack，其实就是告诉happypack的核心调度器如何通过一系列的loader去转化一类文件，并且可以指定如何为这类型转换操作分配子进程。核心调度器的代码在主进程中，也就是运行这webpack的进程中，核心调度器会把一个个任务分配给当前的空闲的子进程，子进程处理完毕后将结果返回给核心调度器，他们之间的数据交换是通过进行间的通讯api实现的，核心调度器收到来自子进程处理完毕的结果后，会通知webpack该文件已处理完毕。
4.自动刷新
文件监听watch，文件监听的原理是定时获取这个文件的最后编辑时间，每次都存下最新的最后编辑的时间，如果发现当前的获取的和最后一次保存的时间不一致，就会认为刷新了，watchoption中的poll用来控制定时检查的周期，每秒检查多少次。当发现变化时，并不会直接告诉监听者，先缓存起来，收集一段时间才会一次性告诉监听者，watchoption中的aggregateTimeout用来配置这个等待时间。
所以忽略node_moudles下的监听，
5.模块热替换
只需重新编译新的模块，替换掉老得模块
注意，当子模块发生更新时，更新事件会一层一层向上递，知道有磨蹭的文件接收了当前模块的变化，如果一直往外抛，没有接收，就直接刷新网页
### webpack缺陷
无法分别加载每个文件
### 验证webpack的打包规则
    
    
    
    
## 优化

### 函数防抖和节流有什么特点，区别，场景
防抖，只最后一次执行。可以在input输入内容发起请求的时候用
节流，定时执行，可以在滚动的时候触发
### 网页崩溃怎么排查，常见的原因
抓包，查询日志
原因：频繁操作dom,死循环
### 页面的加载时间（工具，各项指标）
1.通过谷歌浏览器开发者工具看各个资源加载的情况
2.DOMContentLoaded/load

        console.log('观察脚本加载的顺序')
        // 页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件，简单来说，页面的load事件会在DOMContentLoaded被触发之后才触发
        window.addEventListener("load", function() {
            let a = document.getElementById('a')
            console.log('load事件回调')
        }, false);
        // 当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等位于脚本前面的css加载完才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。
        document.addEventListener("DOMContentLoaded", function() {
            let a = document.getElementById('a')
            console.log('DOMContentLoaded回调') // 不兼容老的浏览器，兼容写法见[jQuery中ready与load事件] ，原理看下文
        }, false);
    
    
3.通过window.performance.timing
DNS查询耗时 ：domainLookupEnd - domainLookupStart
TCP链接耗时 ：connectEnd - connectStart
request请求耗时 ：responseEnd - responseStart
解析dom树耗时 ： domComplete- domInteractive
白屏时间 ：responseStart - navigationStart
domready时间 ：domContentLoadedEventEnd - navigationStart
onload时间 ：loadEventEnd - navigationStart

![4](/image/前端面试题集/4.jpg)
4.首屏可加载，首屏可交互概念
### 不同设备版本的兼容性
1.audio元素和video元素在ios和andriod中无法自动播放
原因： 因为各大浏览器都为了节省流量，做出了优化，在用户没有行为动作时（交互）不予许自动播放；

    /音频，写法一
    <audio src="music/bg.mp3" autoplay loop controls>你的浏览器还不支持哦</audio>
    
    //音频，写法二
    <audio controls="controls"> 
        <source src="music/bg.ogg" type="audio/ogg"></source>
        <source src="music/bg.mp3" type="audio/mpeg"></source>
        优先播放音乐bg.ogg，不支持在播放bg.mp3
    </audio>
    
    //JS绑定自动播放（操作window时，播放音乐）
    $(window).one('touchstart', function(){
        music.play();
    })
    
    //微信下兼容处理
    document.addEventListener("WeixinJSBridgeReady", function () {
        music.play();
    }, false);
    
    //小结
    //1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常；
    //2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间；
    //3.注意不要遗漏微信的兼容处理需要引用微信JS；
2.上传图片，iPhone7 iPhone7p在上传图片的时候，传不过去图片的name
手动添加图片name

    let data = new FormData();
    data.append("fileName", file[0],file[0].name);     

3.ios如果有fixed布局，滚动时底部定位的没了

    -webkit-overflow-scrolling:touch // 回弹效果，有fiexd不能设置
    -webkit-overflow-scrolling:auto // 无回弹效果

4.ios12虚拟键盘收起的时候，键盘区域留白问题
    
    handleblur() {
         window.scrollTo(0, 0);
    }
5.ios输入英文会有空格
    
    this.value = this.value.replace(/\u2006/g,'');

6.ie10不兼容vue-echar，改成eachar
7.ios键盘遮挡屏幕的问题
        
    document.querySelector('#inputId').scrollIntoView();
但是多次测试，仍然存在问题：当切换输入法的时候，input框的位置会往下移动，被键盘挡住一部分，而且出现的概率比较高（中英文切换）
8.ios input光标错乱的问题

### pwa server  
    
### 前端优化具体的做法

- http层面优化

减少cookie
coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。

使用http缓存
HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，一般分为强制缓存和对比缓存，强制缓存判断HTTP首部字段：cache-control,Expires.Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件，但是该方法存在一个问题，服务器时间和客户端时间可能不一致。Cache-control中的max-age保存一个相对时间，例如cache-control:max-age = 484200,表示浏览器收到文件后，缓存在484200s内有效，如果同时存在cache-control和Expires，浏览器总是优先使用cache-control.
对比缓存通过HTTP的last-modified,Etag字段进行判断，last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间，下次浏览器请求资源时就发送if-modified-since字段，服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致就认为缓存已过期并返回新资源给浏览器，如果时间一致就发送304状态码，让浏览器继续使用缓存。Etag：资源的实体标志（哈西字符串），当资源内容更新时Etag会改变，服务器会判断Etag是否发生变化，如果变化则返回新资源。

![3](/image/输入url会发生什么/3.jpg)

- 资源优化

图片优化
jpeg/jpg:体积小，有损压缩，一般背景图，轮播图会用得到，缺点不支持透明，压缩过后有些图片会模糊
png:无损压缩，支持透明，小logo并且颜色丰富的时候会用到，但是它体积较大
svg:无限放大不失真，体积更小，压缩性更强，兼容性好，但渲染成本高
base64:编码，可减少请求次数，非常小的小icon,但base64编码后，图片会膨胀为原来大小的3/4
按照需求选择更适合的图片
同时避免image标签的src为空，因为浏览器加载到image标签发现它空，就会以为自己没加载到，会再次请求一遍。

体积优化
压缩静态资源：合并打包的js、css文件体积一般会比较大，一些图片也会比较大，这个时候必须要压缩处理。
编写高效率的CSS：减少深层次嵌套，减少元素选择器使用等等

资源加载优化
静态资源部署cdn
按需加载，同域名内的文件充分的进行压缩
资源预加载，通过prefetch/preload

    // 实行prefetch，注意只有webpack 4版本才支持prefetch功能。
    import(
        /* webpackPrefetch: true */
        /*webpackChunkName: 'topic'*/
        "../topic"
      )
>webpack的动态import()需要指定包命，如果不在注释中说明包名，那么用了几次import() , webpack就会给同一个文件打包多少次。使得我们prefetch的文件和路由中要用到的文件并不是同一个文件。

     
      
- 渲染优化

DOM节点优化
太多不利于seo，也不利于渲染

懒加载
最常见的场景是在图片的懒加载中，先用一种loading的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。

动态加载
动态加载脚本就是利用javascript代码来加载脚本，通常是手工创建script元素，然后等到HTML文档解析完毕后插入到文档中去。这样就可以很好地控制脚本加载的时机，从而避免阻塞问题。


    function loadJS(src) {
      const script = document.createElement('script');
      script.src = src;
      document.getElementsByTagName('head')[0].appendChild(script);
    }
    loadJS('http://example.com/scq000.js');
 
未来所需组件预加载
 
减少重排重绘
当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。
简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘，但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。
触发重排和重绘的情况：
添加、删除、更新 DOM 节点
display: none 隐藏一个 DOM 节点-触发重排和重绘
通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化
移动或者给页面中的 DOM 节点添加动画
添加一个样式表，调整样式属性
用户行为，例如调整窗口大小，改变字号，或者滚动。
解决方法：
让该元素脱离文档流->对其进行多重改变->将元素带回文档中

- 打包优化
mini-css-extract-plugin提取css
new OptimizeCSSAssetsPlugin()压缩css
cdn
splitChunks
>提取webpack的runtime代码到单独manifest的文件
 所有静态依赖第三方库被分割到同一个文件中,通过cacheGroup
 多入口情况下：被多次引用的自研发模块统一放到一个文件中，便于多个入口共享，整一个common
 配置缓存，new webpack.HashedModuleIdsPlugin()
 多入口情况下：在new HtmlWebpackPlugin下的chunks写如对应页面的引用模块名字
 
5.路由按需加载（webpackchunkname）
    
    
## 安全
### CSRF攻击
CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。
CSRF攻击攻击原理及过程如下：
1.用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3.用户未退出网站A之前，或者说是本地cookie没有失效，在同一浏览器中，打开一个TAB页访问网站B；
4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

### XSS攻击
场景：想象一下 JSONP 就是你请求 http://youdomain.com?callback=douniwan, 然后返回 douniwan({ data })，那假如请求 http://youdomain.com?callback=<script>'console.log(1)'</script> 不就返回 <script>console.log(1)</script>({ data })了吗，如果没有严格定义好 Content-Type（ Content-Type: application/json ），再加上没有过滤 callback 参数，直接当 html 解析了，就是一个赤裸裸的 XSS 了。
原则：不相信客户输入的数据
解决方法
严格定义 Content-Type: application/json
然后严格过滤 callback 后的参数并且限制长度（进行字符转义，例如<换成&lt，>换成&gt）等，这样返回的脚本内容会变成文本格式，脚本将不会执行。
将重要的cookie标记为http only,这样的话Javascript 中的document.cookie语句就不能获取到cookie了.
只允许用户输入我们期望的数据。
过滤JavaScript 事件的标签。例如 "onclick=", "onfocus" 等等。

## 架构
### 前端工程化
模块化、组件化、规范化、自动化
1.模块化
模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。现有的es6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范。
webpack可以将文件打包成一个文件，也可以搭乘多个chunk,资源模块化
CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。
2.组件化
从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。
模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。
3.规范化
结构规范/编码规范/接口规范/文档规范/commit规范
4.自动化
webpack编译打包，实时刷新等等

## 项目
1.rn中转
    
    <script type="text/javascript">
        (function () {
          var UA = navigator && navigator.userAgent || "";
          var href = location && location.href || "";
            var skuId
            var search = location.search
            if (search) {
              var arr = search.match(/skuId=(\d*)/)
              if (arr) {
                skuId = arr[1]
              }
            }
            var param = ''
            if (skuId) {
              param = `,"skuId":"${skuId}"`
            }
            location.href = `openapp`
            document.addEventListener("visibilitychange", function () {
              if (!!UA.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/)) {
                location.href = 'closeApp://webview?refresh=true';
              } else {
                Android.finishWebActivity();
              }
            });
        })()
      </script>

2.心愿单平台化
存在的问题：耦合，当面向的是前端和运营，分别做什么；B端C端考虑
3.前端控制权限
![3](/image/前端面试题集/3.jpg)
4.如何对音频和视频资源进行预加载

