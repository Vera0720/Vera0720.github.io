---
title: 前端面试题集
date: 2020-02-29 22:30:22
tags: 面试
---
按照分类整理了一波面试题，后续会慢慢补充答案的。

<!-- more -->

## HTTP
### 服务器接受请求时head头里能拿到什么
Headers主要分为Response Headers（响应）和Request Headers（请求）两部分
### http缓存
强制缓存（cache-control:max-age || Expries），对比缓存(lastmodified && ETag)
html页面禁用缓存的设置如下：
<meta http-equiv="pragma" content="no-cache">
// 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求
<meta http-equiv="cache-control" content="no-cache">
// 其他主流浏览器识别的标签
<meta http-equiv="expires" content="0">
// 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段
html设置缓存如下：
<meta http-equiv="Cache-Control" content="max-age=7200" />
// 其他主流浏览器识别的标签
<meta http-equiv="Expires" content="Mon, 20 Aug 2018 23:00:00 GMT" />
// 仅有IE浏览器才识别的标签
### 输入url发生什么

1.浏览器的地址栏输入url并按下回车

2.浏览器查找当前url是否存在缓存，并比较缓存是否过期

3.DNS解析url对应的IP

4.根据IP建立TCP连接（三次握手）

5.服务器端处理（动态页面处理，静态页面返回。CDN相关）

6.HTTP发起请求

7.服务器处理请求，浏览器接收HTTP响应

8.渲染页面，构建DOM树（收到HTML内容解析，并行加载串行执行执行CSS，js）

9.请求头内容缓存到浏览器端

10.关闭TCP连接，4次握手

## CSS

### 盒模型
> 标准盒模型及怪异盒模型，box-sizing:content-box/border-box

        // 标准盒模型，实际宽为200+1*2+10*2
        .content-box{
            box-sizing:content-box;
            width:200px;
            height:200px;
            border:1px solid #000;
            padding:10px;
        }
        // 怪异盒模型,实际宽为200（10*2+1*2+178）
        .content-box{
            box-sizing:border-box;
            width:200px;
            height:200px;
            border:1px solid #000;
            padding:10px;
            margin:10px;
        }

### flex
>弹性盒模型，不兼容ie9以下

        1.容器基本属性：
        - flex-direction(主轴方向的排列方法):row/row-reverse/column/column-reverse
        - flex-wrap: wrap/no-wrap/wrap-reverse
        - flex-flow: <flex-direction>  <flex-wrap>;
        - justify-content（项目在主轴上的对齐方式）: center/flex-start/flex-end/space-between/space-around
        - align-items（项目在交叉上的对齐方式）: center/flex-start/flex-end/baseline（项目的第一行文字的基线对齐）/stretch（如果项目未设置高度或设为auto，将占满整个容器的高度。）
        - align-content（定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用）: flex-start | flex-end | center | space-between | space-around | stretch
        2. 项目基本属性
        - order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。
        - flex-grow:定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
        - flex-shrink:项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。0为原有大小
        - flex-basis: 在分配多余空间之前，项目占据的主轴空间 <length> | auto
        - flex:flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
        - align-self:单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。


### input的placeholder
>
        css选择:input::placeholder
        垂直居中:line-height: normal
    
### rem原理
>本质是等比缩放，一般是基于宽度。一般是通过两种方式来设置

        1.sass
        
        $width: 750; /* ui图的宽度 */
        
        @function px2rem($px) {
          @return #{$px/$width*100}rem;
        }
        
        p {
          width: px2rem(100);
        }
        
        2.head头里计算根结点字体大小
        
        window.onresize = function () {
            resetFontSize()
        };
        function resetFontSize() {
            document.documentElement.style.fontSize = document.documentElement.clientWidth / 3.75 + 'px';
        }
        resetFontSize()


### box-show
### 水平垂直居中
>可以通过flex布局，position+margin/transform:translate(-50%,-50%)
### 动画
>animation/transition/transform

        // animation
        @keyframes actWith {
            from {
                background: red;
            }
            to{
                background: yellow;
            }
        }
        @keyframes actWith {
            10% {
                background: red;
            }
            50%{
                background: yellow;
            }
            100%{
                background: blue;
            }
        }
        div {
            animation: actWith 5s;          
            // animation: name duration timing-function（line,ease...） delay iteration-count direction fill-mode play-state;
        }
        
        // transition 需要事件的触发
        // transition: property duration timing-function delay;
        div{
            // transform  旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix
            transform:rotate(7deg);
        }
               
### 定位
>static(不同里文档流，默认)，relative(相对与原有本身位置，不脱离文档流)，absolute(相对非static已定位最近父元素,脱离文档流)，fixed(相对与当前浏览器窗口，脱离文档流)
### BFC
>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
        
        - 布局规则
        1.内部的Box会在垂直方向，一个接一个地放置。
        2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。   
        3.每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
        4.BFC的区域不会与float box重叠。
        5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
        - 如何创建BFC
        1.float非none
        2.position非statcic,relative
        3.overflow非visible
        4.display的值为table-call,inline-block,flex,table-caption,inline-flex
        
### margin折叠
>在CSS中，【两个或多个】 【毗邻】 的 【普通流】 中的盒子（可能是父子元素，也可能是兄弟元素）在 【垂直方向】 上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。
        
        .parent1 {
            width: 100px;
            height: 100px;
            background: yellow;
            margin-bottom: 20px;
        }
        .parent2 {
            width: 100px;
            height: 300px;
            margin-top: 30px;
            background: blue;
            margin-bottom: 30px;
        }
        .parent3 {
            width: 100px;
            height: 100px;
            background: green;
            margin-top: 50px;

        }
        .child {
            background: red;
            height: 20px;
            margin-top: 50px;
            margin-bottom: 60px;
        }
        .parent-2{
            width: 100px;
            height: 500px;
            background: black;
        }
        .child-2{
            width: 100px;
            height: 100px;
            margin-top: 50px;
            background: bisque;
        }
                
        <div class="parent1"></div>
        <div class="parent2">
            <div class="child"></div>
            <div class="child"></div>
            <div class="child"></div>
        </div>
        <div class="parent3"></div>
        <div class="parent-2">
            <div class="child-2"></div>
        </div>
            
            

## JS
### es6
#### es6的新增语法
#### let与var的区别，为什么不能变量提升，重复复值，const为什么在有些情况下可以改变
let 的「创建」过程被提升了，但是初始化没有提升。
var 的「创建」和「初始化」都被提升了。
function 的「创建」「初始化」和「赋值」都被提升了。

如果let x = d ;抱错，x 变量就将永远处于 created 状态。
你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。
由于 x 无法被初始化，所以 x 永远处在暂时死区

let 声明会提升到块顶部
从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区）
如果你在 TDZ 内使用该变量，JS 就会报错

const是赋值本身不可变，对象的地址不可变，但可以对对象增加修改删除属性
### promise
#### promise的常用api
then,catch,resolve,reject,all,race
#### 如何实现一个带休眠的promise
直接在promise里写settimeout延迟2秒触发reject
新建一个定时任务，通过.race，让两个promise进行比较
#### 如何实现两个接口的链式调用
return一个promise用.then调用，也可以用async,await
#### 事件循环
#### promise原理
#### then(a,b)与then(a).catch(b)一样么
在then里发生错误的时候，不会被then的第二个函数捕获。
### 数组
#### 数组的方法
push,pop,shift,unshift,splice,slice,indexof,concat,join,sort,reverse,fiflter,map,foreach,find
#### 数组的哪些方法能够改变原数组
pop,push,shift,unshift,sort,reverse,splice
#### 实现一个数组的深拷贝和浅拷贝
        
        
            // 浅拷贝
            let shallowClone = function (obj) {
                // 不是对象的话，return
                if(typeof obj != 'Object'){
                    return false
                }
            
                // 根据类型判断应该新建一个数组还是对象
                let newObj = obj instanceof Array ? [] : {}
                // 遍历obj，只有obj的属性才拷贝
                for(let key in obj){
                    if(obj.hasOwnProperty(key)){
                        newObj[key] = obj[key]
                    }
                }
                return newObj
            }
            // 深拷贝
            let deepClone = function (obj) {
                // 不是对象的话，return
                if(typeof obj != 'object'){
                    return false
                }
            
                // 根据类型判断应该新建一个数组还是对象
                let newObj = obj instanceof Array ? [] : {}
                // 遍历obj，obj所有的属性都拷贝
                for(let key in obj){
                    if(obj.hasOwnProperty(key)){
                        newObj[key] = (typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key])
                    }
                }
                return newObj
            }
#### 查找数组中最大的一个数
1.Math.max(...arr)
2.for
3.sort/sort+reserve
#### 数组去重
indexof-不能过滤掉 NaN、Object
filter-不能过滤掉 NaN、Object
for-不能过滤掉 NaN、Object
map-不能过滤重复的Object
set-不能过滤重复的Object
includes-不能过滤重复的Object
利用对象的key-nan，object都能过滤掉，但是会把‘nan’和nan视为同一个
### 其他
apply,call,bind的区别
如何实现继承

## VUE

- computed和vuex里的getter有什么区别
- vuex原理 
- v-model实现的原理
- vue的双向数据绑定
- 自定义指令

### watch和computed的区别
computed是计算属性，类似与过滤器，对绑定在view上的数据进行处理，computed的属性不能在data里赋值,具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数
watch是一个观察动作，可以通过deep:true来进行深度监听。打印oldVal和newVal值一样的原因是它们索引同一个对象/数组，Vue 不会保留修改之前值的副本，深度监听的函数必须是handler，因为watcher里面对应的是对handler的调用.无缓存性，页面重新渲染时值不变化也会执行
    
     watch:{
          secondChange:{
            handler(oldVal,newVal){
              console.log(oldVal)
              console.log(newVal)
            },
            deep:true
          }
        },

监听对象单个属性

    // 方法一：可以直接对用对象.属性的方法拿到属性
    data(){
      return{
        'first':{
          second:0
        }
      }
    },
    watch:{
      first.second:function(newVal,oldVal){
        console.log(newVal,oldVal);
      }
    }
    
    // 方法二：watch如果想要监听对象的单个属性的变化,必须用computed作为中间件转化,因为computed可以取到对应的属性值
    data(){
      return{
        'first':{
          second:0
        }
      }
    },
    computed:{
      secondChange(){
        return this.first.second
      }
    },
    watch:{
      secondChange(){
        console.log('second属性值变化了')
      }
    },
               
### 过滤器


    <!-- 在双花括号中 -->
    {{ message | capitalize }}
    
    <!-- 在 `v-bind` 中 -->
    <div v-bind:id="rawId | formatId"></div>
    
    filters: {
      capitalize: function (value) {
        if (!value) return ''
        value = value.toString()
        return value.charAt(0).toUpperCase() + value.slice(1)
      }
    }
    
    
### 父子组件的通讯
父子组件通信: props; $parent / $children; provide / inject ; ref ; $attrs / $listeners
兄弟组件通信: eventBus ; vuex
跨级通信: eventBus；Vuex；provide / inject 、$attrs / $listeners
### localstorage怎么监听
同源的不同页面，监听事件就行了

    window.addEventListener("storage", function (e) {
            alert(e.newValue);
    });
同页面，对 localStorage 的 setItem 方法进行重写
    
    var orignalSetItem = localStorage.setItem;
    localStorage.setItem = function(key,newValue){
          var setItemEvent = new Event("setItemEvent");
          setItemEvent.key = key;
          setItemEvent.newValue = newValue;
          window.dispatchEvent(setItemEvent);
          orignalSetItem.apply(this,arguments);
    }
    window.addEventListener("setItemEvent", function (e) {
        alert(e.newValue);
    });
    localStorage.setItem("name","wang");

在vue中

    /**
     * @param { number } type 1 localStorage 2 sessionStorage
     * @param { string } key 键
     * @param { string } data 要存储的数据
     * @returns 
     */
    // 如果报prototype无法被识别的错误，可以把原型方法挂在到__proto__
    Vue.prototype.$addStorageEvent = function (type, key, data) {
        if (type === 1) {
            // 创建一个StorageEvent事件
            var newStorageEvent = document.createEvent('StorageEvent');
            const storage = {
                setItem: function (k, val) {
                    localStorage.setItem(k, val);
                    // 初始化创建的事件
                    newStorageEvent.initStorageEvent('setItem', false, false, k, null, val, null, null);
                    // 派发对象
                    window.dispatchEvent(newStorageEvent);
                }
            }
            return storage.setItem(key, data);
        } else {
            // 创建一个StorageEvent事件
            var newStorageEvent = document.createEvent('StorageEvent');
            const storage = {
                setItem: function (k, val) {
                    sessionStorage.setItem(k, val);
                    // 初始化创建的事件
                    newStorageEvent.initStorageEvent('setItem', false, false, k, null, val, null, null);
                    // 派发对象
                    window.dispatchEvent(newStorageEvent);
                }
            }
            return storage.setItem(key, data);
        }
    }
    二、组件中调用：
    
    this.$addStorageEvent(2, "user_info", data);
    三、在另一个组件中的 mounted 钩子函数中监听：
    
    window.addEventListener('setItem', (e) => {
      //获取参数
         console.log(e);
    });
    
### 组件的类别
全局组件和局部组件
全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。
### vue-router实现路由懒加载

1.import按需加载（官方写法）

    const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')

2.vue异步组件

    {
        path: '/path',
        name: 'componentName',
        component: resolve => require(['@/componentPath'], resolve),
    }
      
### 动态加载路由

    const router = new Router({
      routes: [
        {path: '/', redirect: '/home'},
      ]  
    })
     
    router.addRoutes([
      {
        path: '/login',
        name: 'login',
        component: () => import('../components/Login.vue')
      }
    ])
### 路由守卫
全局前置守卫 beforeEach(to,from,next)
全局后置守卫 afterEach(to,from)
路由守卫 beforeEnter(to, from, next)
组件内守卫 beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave

完整的导航解析流程
1.导航被触发。
2.在失活的组件里调用 beforeRouteLeave 守卫。
3.调用全局的 beforeEach 守卫。
4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5.在路由配置里调用 beforeEnter。
6.解析异步路由组件。
7.在被激活的组件里调用 beforeRouteEnter。
8.调用全局的 beforeResolve 守卫 (2.5+)。
9.导航被确认。
10.调用全局的 afterEach 钩子。
11.触发 DOM 更新。
12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
### axios请求封装，拦截器

## REACT

- react的生命周期
- setState有时候是同步的？异步？批量更新
- 组件的类型，如何创建组件
- redux原理，流程
- 热更新

## WEBPACK
### 什么是webpack
webpack是一个打包工具，他的宗旨是一切静态资源皆可打包。规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。
### webpack核心概念
1.Entry（入口）：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
2.Output（出口）：告诉 webpack 在哪里输出它所创建的结果文件，以及如何命名这些文件，默认值为./dist。
3.Loader（模块转换器）：将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。
4.Plugins（插件）：在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。
5.Module(模块)：开发者将程序分解成离散功能块，并称之为模块，在webpack里一个模块对应着一个文件，webpack会从配置的 Entry 开始递归找出所有依赖的模块。
### webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全
webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，每找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑
Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：
初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
确定入口：根据配置中的 entry 找出所有的入口文件；
编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。
### Webpack与Grunt和Gulp的区别
Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。
Grunt和Gulp的工作方式是：基于任务和流（Task、Stream）的，在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。
gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系。webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工
### loader
1.什么是loader
Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力
2.常见的locader
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去
source-map-loader：加载额外的 Source Map 文件，以方便断点调试
image-loader：加载并且压缩图片文件
babel-loader：把 ES6 转换成 ES5
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
eslint-loader：通过 ESLint 检查 JavaScript 代码
3.loader原理
### Plugin
1.常见的Plugin
define-plugin：定义环境变量
HtmlWebpackPlugin:可以生成创建html入口文件,为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题
uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码，删除警告
CleanWebpackPlugin：清除打包的文件
HotModuleReplacementPlugin：热重载（更新的模块重载）
2.plugin的原理
### 用 webpack 实现 long term cache
思路：哪个模块更新了破坏他的缓存，没更新的模块继续利用缓存。 
1.code splitting

    // 1.多entry方式
    entry: {
        a: './code_split_mode/a.js',
        b: './code_split_mode/b.js'
    },
    // 2.公共提取,拆分代码配置项方式
    optimization: {
        splitChunks: {
          cacheGroups: {
            node_vendors: {
              test: /[\\/]node_modules[\\/]/,
              chunks: 'async',
              priority: 1
            }
          }
        }
    },
    // 3.动态加载
    output: {
      path: config.build.assetsRoot,
      filename: utils.assetsPath('js/[name].[chunkhash].js'),
      chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
    },
    // 4.动态加载在vue中
    // 把每个路由所包含的组件，都分割成一个单独的 bundle（通过import()就已经可以实现了）；当路由被访问的时候才加载该路由对应的 bundle（ue 允许将组件定义为一个工厂函数，异步地解析组件的定义。只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。在工厂函数中可以返回 Promise，而 import() 也是返回 Promise 的，这样就把异步组件和 import() 结合起来了。）
    const router = new VueRouter({
      routes: [
        { path: '/login', component: () => import('@/views/login'), },
        { path: '/home', component: () => import('@/views/home'), }
      ]
    })
      
2.生成稳定的 hash 文件名
    
      output: {
        //...
        filename: '[name].[chunkhash:8].js',
        chunkFilename: '[name].[chunkhash:8].chunk.js',
        //...
      },
    }
    
3.提取 webpack 的 runtime 代码（用来解析和加载模块之类的运行时代码）
    
    new webpack.optimize.CommonsChunkPlugin({ 
      name: ['manifast'] 
    }),
    
4.保持moudule的id
webpack 里每个模块都有一个 module id ，module id 是该模块在模块依赖关系图里按顺序分配的序号，如果这个 module id 发生了变化，那么他的 chunkhash 也会发生变化。
    
    plugins: [
      new webpack.HashedModuleIdsPlugin(),
      // ...
    ],
### 使用webpack优化体积
1.mini-css-extract-plugin提取css
2.new OptimizeCSSAssetsPlugin()压缩css
3.cdn
4.splitChunks
5.路由按需加载（webpackchunkname）    
    
    
    
    
## 优化

### 函数防抖和节流有什么特点，区别，场景
防抖，只最后一次执行。可以在input输入内容发起请求的时候用
节流，定时执行，可以在滚动的时候触发
### 前端优化
### 网页崩溃怎么排查，常见的原因
抓包，查询日志
原因：频繁操作dom,死循环
### 页面的加载时间（工具，各项指标）
1.通过谷歌浏览器开发者工具看各个资源加载的情况
2.DOMContentLoaded/load

        console.log('观察脚本加载的顺序')
        window.addEventListener("load", function() {
            let a = document.getElementById('a')
            console.log('load事件回调')
        }, false);
        document.addEventListener("DOMContentLoaded", function() {
            let a = document.getElementById('a')
            console.log('DOMContentLoaded回调') // 不兼容老的浏览器，兼容写法见[jQuery中ready与load事件] ，原理看下文
        }, false);
    
    
3.通过window.performance.timing
DNS查询耗时 ：domainLookupEnd - domainLookupStart
TCP链接耗时 ：connectEnd - connectStart
request请求耗时 ：responseEnd - responseStart
解析dom树耗时 ： domComplete- domInteractive
白屏时间 ：responseStart - navigationStart
domready时间 ：domContentLoadedEventEnd - navigationStart
onload时间 ：loadEventEnd - navigationStart
### cdn
### 不同设备版本的兼容性

## 架构
