---
title: 前端优化系列之首屏优化
date: 2019-10-11 10:41:33
tags: js
---
最近有个需求，就是首屏访问的时候速度很慢，产品想让我们优化到1秒内打开，所以大概用了一个星期的时间，搞定了优化。
原则上多使用内存，缓存或者其他方法，减少CPU计算，减少网络请求，减少IO操作（硬盘读写）
   
<!-- more -->

首先考虑到从输入URL到页面加载完成，完整的链路过程。
DNS解析->TCP连接->HTTP请求->HTTP响应->渲染
![1.png](/image/前端优化/1.jpg)


## http层面优化

减少cookie
coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。

使用http缓存
HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，一般分为强制缓存和对比缓存，强制缓存判断HTTP首部字段：cache-control,Expires.Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件，但是该方法存在一个问题，服务器时间和客户端时间可能不一致。Cache-control中的max-age保存一个相对时间，例如cache-control:max-age = 484200,表示浏览器收到文件后，缓存在484200s内有效，如果同时存在cache-control和Expires，浏览器总是优先使用cache-control.
对比缓存通过HTTP的last-modified,Etag字段进行判断，last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间，下次浏览器请求资源时就发送if-modified-since字段，服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致就认为缓存已过期并返回新资源给浏览器，如果时间一致就发送304状态码，让浏览器继续使用缓存。Etag：资源的实体标志（哈西字符串），当资源内容更新时Etag会改变，服务器会判断Etag是否发生变化，如果变化则返回新资源。

![3](/image/输入url会发生什么/3.jpg)

## 资源优化

图片优化
jpeg/jpg:体积小，有损压缩，一般背景图，轮播图会用得到，缺点不支持透明，压缩过后有些图片会模糊
png:无损压缩，支持透明，小logo并且颜色丰富的时候会用到，但是它体积较大
svg:无限放大不失真，体积更小，压缩性更强，兼容性好，但渲染成本高
base64:编码，可减少请求次数，非常小的小icon,但base64编码后，图片会膨胀为原来大小的3/4
按照需求选择更适合的图片
同时避免image标签的src为空，因为浏览器加载到image标签发现它空，就会以为自己没加载到，会再次请求一遍。

体积优化
压缩静态资源：合并打包的js、css文件体积一般会比较大，一些图片也会比较大，这个时候必须要压缩处理。
编写高效率的CSS：减少深层次嵌套，减少元素选择器使用等等

资源加载优化
静态资源部署cdn
按需加载，同域名内的文件充分的进行压缩
资源预加载，通过prefetch/preload

    // 实行prefetch，注意只有webpack 4版本才支持prefetch功能。
    import(
        /* webpackPrefetch: true */
        /*webpackChunkName: 'topic'*/
        "../topic"
      )
>webpack的动态import()需要指定包命，如果不在注释中说明包名，那么用了几次import() , webpack就会给同一个文件打包多少次。使得我们prefetch的文件和路由中要用到的文件并不是同一个文件。

     
      
## 渲染优化

DOM节点优化
太多不利于seo，也不利于渲染

懒加载
最常见的场景是在图片的懒加载中，先用一种loading的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。

动态加载
动态加载脚本就是利用javascript代码来加载脚本，通常是手工创建script元素，然后等到HTML文档解析完毕后插入到文档中去。这样就可以很好地控制脚本加载的时机，从而避免阻塞问题。


    function loadJS(src) {
      const script = document.createElement('script');
      script.src = src;
      document.getElementsByTagName('head')[0].appendChild(script);
    }
    loadJS('http://example.com/scq000.js');
 
未来所需组件预加载
 
减少重排重绘
当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。
简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘，但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。
触发重排和重绘的情况：
添加、删除、更新 DOM 节点
display: none 隐藏一个 DOM 节点-触发重排和重绘
通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化
移动或者给页面中的 DOM 节点添加动画
添加一个样式表，调整样式属性
用户行为，例如调整窗口大小，改变字号，或者滚动。
解决方法：
让该元素脱离文档流->对其进行多重改变->将元素带回文档中

## 打包优化
mini-css-extract-plugin提取css
new OptimizeCSSAssetsPlugin()压缩css
cdn
splitChunks
>提取webpack的runtime代码到单独manifest的文件
 所有静态依赖第三方库被分割到同一个文件中,通过cacheGroup
 多入口情况下：被多次引用的自研发模块统一放到一个文件中，便于多个入口共享，整一个common
 配置缓存，new webpack.HashedModuleIdsPlugin()
 多入口情况下：在new HtmlWebpackPlugin下的chunks写如对应页面的引用模块名字
 
5.路由按需加载（webpackchunkname）
