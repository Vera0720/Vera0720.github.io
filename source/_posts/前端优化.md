---
title: 前端优化
date: 2019-10-11 10:41:33
tags: js
---
最近有个需求，就是首屏访问的时候速度很慢，产品想让我们优化到1秒内打开，所以大概用了一个星期的时间，搞定了优化。
原则上多使用内存，缓存或者其他方法，减少CPU计算，减少网络请求，减少IO操作（硬盘读写）
   
<!-- more -->

首先考虑到从输入URL到页面加载完成，完整的链路过程。
DNS解析->TCP连接->HTTP请求->HTTP响应->渲染
![1.png](/image/前端优化/1.jpg)

### http层面优化

- 浏览器并发
基于端口跟线程切换开销，浏览器不可能无限的并发请求。chrome的并发为6，超过限制数目的请求就会被阻塞
- http请求次数
减少http的请求次数，将多个请求合并成同一个，减少http的开销
- 减少cookie
coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。

所以对首屏的接口进行整合，减少不必要的接口请求。css/js合并打包

### 资源优化

- 图片优化
jpeg/jpg:体积小，有损压缩，一般背景图，轮播图会用得到，缺点不支持透明，压缩过后有些图片会模糊
png:无损压缩，支持透明，小logo并且颜色丰富的时候会用到，但是它体积较大
svg:无限放大不失真，体积更小，压缩性更强，兼容性好，但渲染成本高
base64:编码，可减少请求次数，非常小的小icon,但base64编码后，图片会膨胀为原来大小的3/4
按照需求选择更适合的图片
同时避免image标签的src为空，因为浏览器加载到image标签发现它空，就会以为自己没加载到，会再次请求一遍。

- 体积优化
压缩静态资源：合并打包的js、css文件体积一般会比较大，一些图片也会比较大，这个时候必须要压缩处理。
编写高效率的CSS：减少深层次嵌套，减少元素选择器使用等等

- 资源加载优化
浏览器对同域名并发请求是有数量限制一般是6个，所以考虑到静态资源部署cdn
按需加载，同域名内的文件充分的进行压缩

### 渲染优化

- 懒加载
最常见的场景是在图片的懒加载中，先用一种loading的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。

- 动态加载
动态加载脚本就是利用javascript代码来加载脚本，通常是手工创建script元素，然后等到HTML文档解析完毕后插入到文档中去。这样就可以很好地控制脚本加载的时机，从而避免阻塞问题。


    function loadJS(src) {
      const script = document.createElement('script');
      script.src = src;
      document.getElementsByTagName('head')[0].appendChild(script);
    }
    loadJS('http://example.com/scq000.js');
 
- 未来所需组件预加载
 
- 减少重排重绘
当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。
简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘，但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。
触发重排和重绘的情况：
添加、删除、更新 DOM 节点
display: none 隐藏一个 DOM 节点-触发重排和重绘
通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化
移动或者给页面中的 DOM 节点添加动画
添加一个样式表，调整样式属性
用户行为，例如调整窗口大小，改变字号，或者滚动。
解决方法：
让该元素脱离文档流->对其进行多重改变->将元素带回文档中

### 打包优化














